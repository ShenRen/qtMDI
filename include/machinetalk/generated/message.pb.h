// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "nanopb.pb.h"
#include "types.pb.h"
#include "object.pb.h"
#include "log.pb.h"
#include "motcmds.pb.h"
#include "task.pb.h"
#include "canon.pb.h"
#include "value.pb.h"
#include "rtapicommand.pb.h"
#include "rtapi_message.pb.h"
#include "config.pb.h"
#include "preview.pb.h"
#include "status.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_message_2eproto();
void protobuf_AssignDesc_message_2eproto();
void protobuf_ShutdownFile_message_2eproto();

class Container;

// ===================================================================

class Container : public ::google::protobuf::Message {
 public:
  Container();
  virtual ~Container();
  
  Container(const Container& from);
  
  inline Container& operator=(const Container& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Container& default_instance();
  
  void Swap(Container* other);
  
  // implements Message ----------------------------------------------
  
  Container* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Container& from);
  void MergeFrom(const Container& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .pb.ContainerType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline pb::ContainerType type() const;
  inline void set_type(pb::ContainerType value);
  
  // optional sfixed64 tsc = 7;
  inline bool has_tsc() const;
  inline void clear_tsc();
  static const int kTscFieldNumber = 7;
  inline ::google::protobuf::int64 tsc() const;
  inline void set_tsc(::google::protobuf::int64 value);
  
  // repeated .pb.Preview preview = 8;
  inline int preview_size() const;
  inline void clear_preview();
  static const int kPreviewFieldNumber = 8;
  inline const ::pb::Preview& preview(int index) const;
  inline ::pb::Preview* mutable_preview(int index);
  inline ::pb::Preview* add_preview();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Preview >&
      preview() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Preview >*
      mutable_preview();
  
  // optional .pb.MotionCommand motcmd = 9;
  inline bool has_motcmd() const;
  inline void clear_motcmd();
  static const int kMotcmdFieldNumber = 9;
  inline const ::pb::MotionCommand& motcmd() const;
  inline ::pb::MotionCommand* mutable_motcmd();
  inline ::pb::MotionCommand* release_motcmd();
  
  // optional .pb.MotionStatus motstat = 10;
  inline bool has_motstat() const;
  inline void clear_motstat();
  static const int kMotstatFieldNumber = 10;
  inline const ::pb::MotionStatus& motstat() const;
  inline ::pb::MotionStatus* mutable_motstat();
  inline ::pb::MotionStatus* release_motstat();
  
  // optional bytes legacy_motcmd = 11;
  inline bool has_legacy_motcmd() const;
  inline void clear_legacy_motcmd();
  static const int kLegacyMotcmdFieldNumber = 11;
  inline const ::std::string& legacy_motcmd() const;
  inline void set_legacy_motcmd(const ::std::string& value);
  inline void set_legacy_motcmd(const char* value);
  inline void set_legacy_motcmd(const void* value, size_t size);
  inline ::std::string* mutable_legacy_motcmd();
  inline ::std::string* release_legacy_motcmd();
  
  // optional bytes legacy_motstat = 12;
  inline bool has_legacy_motstat() const;
  inline void clear_legacy_motstat();
  static const int kLegacyMotstatFieldNumber = 12;
  inline const ::std::string& legacy_motstat() const;
  inline void set_legacy_motstat(const ::std::string& value);
  inline void set_legacy_motstat(const char* value);
  inline void set_legacy_motstat(const void* value, size_t size);
  inline ::std::string* mutable_legacy_motstat();
  inline ::std::string* release_legacy_motstat();
  
  // optional .pb.RTAPI_Message rtapi_message = 13;
  inline bool has_rtapi_message() const;
  inline void clear_rtapi_message();
  static const int kRtapiMessageFieldNumber = 13;
  inline const ::pb::RTAPI_Message& rtapi_message() const;
  inline ::pb::RTAPI_Message* mutable_rtapi_message();
  inline ::pb::RTAPI_Message* release_rtapi_message();
  
  // optional .pb.TaskReply task_reply = 14;
  inline bool has_task_reply() const;
  inline void clear_task_reply();
  static const int kTaskReplyFieldNumber = 14;
  inline const ::pb::TaskReply& task_reply() const;
  inline ::pb::TaskReply* mutable_task_reply();
  inline ::pb::TaskReply* release_task_reply();
  
  // optional .pb.TicketUpdate ticket_update = 15;
  inline bool has_ticket_update() const;
  inline void clear_ticket_update();
  static const int kTicketUpdateFieldNumber = 15;
  inline const ::pb::TicketUpdate& ticket_update() const;
  inline ::pb::TicketUpdate* mutable_ticket_update();
  inline ::pb::TicketUpdate* release_ticket_update();
  
  // optional bytes syslog = 18;
  inline bool has_syslog() const;
  inline void clear_syslog();
  static const int kSyslogFieldNumber = 18;
  inline const ::std::string& syslog() const;
  inline void set_syslog(const ::std::string& value);
  inline void set_syslog(const char* value);
  inline void set_syslog(const void* value, size_t size);
  inline ::std::string* mutable_syslog();
  inline ::std::string* release_syslog();
  
  // optional bytes legacy_nml = 19;
  inline bool has_legacy_nml() const;
  inline void clear_legacy_nml();
  static const int kLegacyNmlFieldNumber = 19;
  inline const ::std::string& legacy_nml() const;
  inline void set_legacy_nml(const ::std::string& value);
  inline void set_legacy_nml(const char* value);
  inline void set_legacy_nml(const void* value, size_t size);
  inline ::std::string* mutable_legacy_nml();
  inline ::std::string* release_legacy_nml();
  
  // optional bytes legacy_motconfig = 20;
  inline bool has_legacy_motconfig() const;
  inline void clear_legacy_motconfig();
  static const int kLegacyMotconfigFieldNumber = 20;
  inline const ::std::string& legacy_motconfig() const;
  inline void set_legacy_motconfig(const ::std::string& value);
  inline void set_legacy_motconfig(const char* value);
  inline void set_legacy_motconfig(const void* value, size_t size);
  inline ::std::string* mutable_legacy_motconfig();
  inline ::std::string* release_legacy_motconfig();
  
  // optional int32 tv_sec = 21;
  inline bool has_tv_sec() const;
  inline void clear_tv_sec();
  static const int kTvSecFieldNumber = 21;
  inline ::google::protobuf::int32 tv_sec() const;
  inline void set_tv_sec(::google::protobuf::int32 value);
  
  // optional int32 tv_nsec = 22;
  inline bool has_tv_nsec() const;
  inline void clear_tv_nsec();
  static const int kTvNsecFieldNumber = 22;
  inline ::google::protobuf::int32 tv_nsec() const;
  inline void set_tv_nsec(::google::protobuf::int32 value);
  
  // optional string topic = 23;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 23;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  
  // optional bool reply_required = 24;
  inline bool has_reply_required() const;
  inline void clear_reply_required();
  static const int kReplyRequiredFieldNumber = 24;
  inline bool reply_required() const;
  inline void set_reply_required(bool value);
  
  // optional .pb.InterpreterStateType interp_state = 25;
  inline bool has_interp_state() const;
  inline void clear_interp_state();
  static const int kInterpStateFieldNumber = 25;
  inline pb::InterpreterStateType interp_state() const;
  inline void set_interp_state(pb::InterpreterStateType value);
  
  // optional string interp_name = 26;
  inline bool has_interp_name() const;
  inline void clear_interp_name();
  static const int kInterpNameFieldNumber = 26;
  inline const ::std::string& interp_name() const;
  inline void set_interp_name(const ::std::string& value);
  inline void set_interp_name(const char* value);
  inline void set_interp_name(const char* value, size_t size);
  inline ::std::string* mutable_interp_name();
  inline ::std::string* release_interp_name();
  
  // optional int32 rsvp = 30;
  inline bool has_rsvp() const;
  inline void clear_rsvp();
  static const int kRsvpFieldNumber = 30;
  inline ::google::protobuf::int32 rsvp() const;
  inline void set_rsvp(::google::protobuf::int32 value);
  
  // optional .pb.ContainerType in_reply_to = 33;
  inline bool has_in_reply_to() const;
  inline void clear_in_reply_to();
  static const int kInReplyToFieldNumber = 33;
  inline pb::ContainerType in_reply_to() const;
  inline void set_in_reply_to(pb::ContainerType value);
  
  // optional .pb.RCS_STATUS rcs_status = 35;
  inline bool has_rcs_status() const;
  inline void clear_rcs_status();
  static const int kRcsStatusFieldNumber = 35;
  inline pb::RCS_STATUS rcs_status() const;
  inline void set_rcs_status(pb::RCS_STATUS value);
  
  // optional .pb.StatusType status = 40;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 40;
  inline pb::StatusType status() const;
  inline void set_status(pb::StatusType value);
  
  // optional int32 serial = 45;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 45;
  inline ::google::protobuf::int32 serial() const;
  inline void set_serial(::google::protobuf::int32 value);
  
  // optional int32 reply_serial = 50;
  inline bool has_reply_serial() const;
  inline void clear_reply_serial();
  static const int kReplySerialFieldNumber = 50;
  inline ::google::protobuf::int32 reply_serial() const;
  inline void set_reply_serial(::google::protobuf::int32 value);
  
  // optional int32 ticket = 55;
  inline bool has_ticket() const;
  inline void clear_ticket();
  static const int kTicketFieldNumber = 55;
  inline ::google::protobuf::int32 ticket() const;
  inline void set_ticket(::google::protobuf::int32 value);
  
  // optional int32 reply_ticket = 60;
  inline bool has_reply_ticket() const;
  inline void clear_reply_ticket();
  static const int kReplyTicketFieldNumber = 60;
  inline ::google::protobuf::int32 reply_ticket() const;
  inline void set_reply_ticket(::google::protobuf::int32 value);
  
  // optional int32 sequence = 62;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 62;
  inline ::google::protobuf::int32 sequence() const;
  inline void set_sequence(::google::protobuf::int32 value);
  
  // optional int32 credit = 65;
  inline bool has_credit() const;
  inline void clear_credit();
  static const int kCreditFieldNumber = 65;
  inline ::google::protobuf::int32 credit() const;
  inline void set_credit(::google::protobuf::int32 value);
  
  // optional int32 line_number = 66;
  inline bool has_line_number() const;
  inline void clear_line_number();
  static const int kLineNumberFieldNumber = 66;
  inline ::google::protobuf::int32 line_number() const;
  inline void set_line_number(::google::protobuf::int32 value);
  
  // optional string name = 67;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 67;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // repeated string note = 68;
  inline int note_size() const;
  inline void clear_note();
  static const int kNoteFieldNumber = 68;
  inline const ::std::string& note(int index) const;
  inline ::std::string* mutable_note(int index);
  inline void set_note(int index, const ::std::string& value);
  inline void set_note(int index, const char* value);
  inline void set_note(int index, const char* value, size_t size);
  inline ::std::string* add_note();
  inline void add_note(const ::std::string& value);
  inline void add_note(const char* value);
  inline void add_note(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& note() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_note();
  
  // optional int32 retcode = 69;
  inline bool has_retcode() const;
  inline void clear_retcode();
  static const int kRetcodeFieldNumber = 69;
  inline ::google::protobuf::int32 retcode() const;
  inline void set_retcode(::google::protobuf::int32 value);
  
  // optional bytes uuid = 72;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 72;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  
  // optional bool trace = 75;
  inline bool has_trace() const;
  inline void clear_trace();
  static const int kTraceFieldNumber = 75;
  inline bool trace() const;
  inline void set_trace(bool value);
  
  // optional int32 instance = 77;
  inline bool has_instance() const;
  inline void clear_instance();
  static const int kInstanceFieldNumber = 77;
  inline ::google::protobuf::int32 instance() const;
  inline void set_instance(::google::protobuf::int32 value);
  
  // repeated .pb.Value value = 85;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 85;
  inline const ::pb::Value& value(int index) const;
  inline ::pb::Value* mutable_value(int index);
  inline ::pb::Value* add_value();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Value >&
      value() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Value >*
      mutable_value();
  
  // optional .pb.RTAPICommand rtapicmd = 86;
  inline bool has_rtapicmd() const;
  inline void clear_rtapicmd();
  static const int kRtapicmdFieldNumber = 86;
  inline const ::pb::RTAPICommand& rtapicmd() const;
  inline ::pb::RTAPICommand* mutable_rtapicmd();
  inline ::pb::RTAPICommand* release_rtapicmd();
  
  // repeated .pb.ServiceAnnouncement service_announcement = 88;
  inline int service_announcement_size() const;
  inline void clear_service_announcement();
  static const int kServiceAnnouncementFieldNumber = 88;
  inline const ::pb::ServiceAnnouncement& service_announcement(int index) const;
  inline ::pb::ServiceAnnouncement* mutable_service_announcement(int index);
  inline ::pb::ServiceAnnouncement* add_service_announcement();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::ServiceAnnouncement >&
      service_announcement() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::ServiceAnnouncement >*
      mutable_service_announcement();
  
  // repeated .pb.Component comp = 100;
  inline int comp_size() const;
  inline void clear_comp();
  static const int kCompFieldNumber = 100;
  inline const ::pb::Component& comp(int index) const;
  inline ::pb::Component* mutable_comp(int index);
  inline ::pb::Component* add_comp();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Component >&
      comp() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Component >*
      mutable_comp();
  
  // repeated .pb.Pin pin = 2;
  inline int pin_size() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 2;
  inline const ::pb::Pin& pin(int index) const;
  inline ::pb::Pin* mutable_pin(int index);
  inline ::pb::Pin* add_pin();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Pin >&
      pin() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Pin >*
      mutable_pin();
  
  // repeated .pb.Signal signal = 3;
  inline int signal_size() const;
  inline void clear_signal();
  static const int kSignalFieldNumber = 3;
  inline const ::pb::Signal& signal(int index) const;
  inline ::pb::Signal* mutable_signal(int index);
  inline ::pb::Signal* add_signal();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Signal >&
      signal() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Signal >*
      mutable_signal();
  
  // repeated .pb.Param param = 103;
  inline int param_size() const;
  inline void clear_param();
  static const int kParamFieldNumber = 103;
  inline const ::pb::Param& param(int index) const;
  inline ::pb::Param* mutable_param(int index);
  inline ::pb::Param* add_param();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Param >&
      param() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Param >*
      mutable_param();
  
  // repeated .pb.Thread thread = 104;
  inline int thread_size() const;
  inline void clear_thread();
  static const int kThreadFieldNumber = 104;
  inline const ::pb::Thread& thread(int index) const;
  inline ::pb::Thread* mutable_thread(int index);
  inline ::pb::Thread* add_thread();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Thread >&
      thread() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Thread >*
      mutable_thread();
  
  // repeated .pb.Ring ring = 105;
  inline int ring_size() const;
  inline void clear_ring();
  static const int kRingFieldNumber = 105;
  inline const ::pb::Ring& ring(int index) const;
  inline ::pb::Ring* mutable_ring(int index);
  inline ::pb::Ring* add_ring();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Ring >&
      ring() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Ring >*
      mutable_ring();
  
  // repeated .pb.Group group = 106;
  inline int group_size() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 106;
  inline const ::pb::Group& group(int index) const;
  inline ::pb::Group* mutable_group(int index);
  inline ::pb::Group* add_group();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Group >&
      group() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Group >*
      mutable_group();
  
  // repeated .pb.Member member = 107;
  inline int member_size() const;
  inline void clear_member();
  static const int kMemberFieldNumber = 107;
  inline const ::pb::Member& member(int index) const;
  inline ::pb::Member* mutable_member(int index);
  inline ::pb::Member* add_member();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Member >&
      member() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Member >*
      mutable_member();
  
  // repeated .pb.Function function = 108;
  inline int function_size() const;
  inline void clear_function();
  static const int kFunctionFieldNumber = 108;
  inline const ::pb::Function& function(int index) const;
  inline ::pb::Function* mutable_function(int index);
  inline ::pb::Function* add_function();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Function >&
      function() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Function >*
      mutable_function();
  
  // optional .pb.ProtocolParameters pparams = 109;
  inline bool has_pparams() const;
  inline void clear_pparams();
  static const int kPparamsFieldNumber = 109;
  inline const ::pb::ProtocolParameters& pparams() const;
  inline ::pb::ProtocolParameters* mutable_pparams();
  inline ::pb::ProtocolParameters* release_pparams();
  
  // repeated .pb.Application app = 120;
  inline int app_size() const;
  inline void clear_app();
  static const int kAppFieldNumber = 120;
  inline const ::pb::Application& app(int index) const;
  inline ::pb::Application* mutable_app(int index);
  inline ::pb::Application* add_app();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Application >&
      app() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Application >*
      mutable_app();
  
  // optional .pb.LogMessage log_message = 87;
  inline bool has_log_message() const;
  inline void clear_log_message();
  static const int kLogMessageFieldNumber = 87;
  inline const ::pb::LogMessage& log_message() const;
  inline ::pb::LogMessage* mutable_log_message();
  inline ::pb::LogMessage* release_log_message();
  
  // optional .pb.TaskPlanExecute tpexecute = 200;
  inline bool has_tpexecute() const;
  inline void clear_tpexecute();
  static const int kTpexecuteFieldNumber = 200;
  inline const ::pb::TaskPlanExecute& tpexecute() const;
  inline ::pb::TaskPlanExecute* mutable_tpexecute();
  inline ::pb::TaskPlanExecute* release_tpexecute();
  
  // optional .pb.TaskPlanBlockDelete tpblockdelete = 201;
  inline bool has_tpblockdelete() const;
  inline void clear_tpblockdelete();
  static const int kTpblockdeleteFieldNumber = 201;
  inline const ::pb::TaskPlanBlockDelete& tpblockdelete() const;
  inline ::pb::TaskPlanBlockDelete* mutable_tpblockdelete();
  inline ::pb::TaskPlanBlockDelete* release_tpblockdelete();
  
  // optional .pb.TaskPlanOptionalStop tpoptionalstop = 202;
  inline bool has_tpoptionalstop() const;
  inline void clear_tpoptionalstop();
  static const int kTpoptionalstopFieldNumber = 202;
  inline const ::pb::TaskPlanOptionalStop& tpoptionalstop() const;
  inline ::pb::TaskPlanOptionalStop* mutable_tpoptionalstop();
  inline ::pb::TaskPlanOptionalStop* release_tpoptionalstop();
  
  // optional .pb.TaskPlanOpen tpopen = 203;
  inline bool has_tpopen() const;
  inline void clear_tpopen();
  static const int kTpopenFieldNumber = 203;
  inline const ::pb::TaskPlanOpen& tpopen() const;
  inline ::pb::TaskPlanOpen* mutable_tpopen();
  inline ::pb::TaskPlanOpen* release_tpopen();
  
  // optional .pb.TaskPlanReply taskplan_reply = 210;
  inline bool has_taskplan_reply() const;
  inline void clear_taskplan_reply();
  static const int kTaskplanReplyFieldNumber = 210;
  inline const ::pb::TaskPlanReply& taskplan_reply() const;
  inline ::pb::TaskPlanReply* mutable_taskplan_reply();
  inline ::pb::TaskPlanReply* release_taskplan_reply();
  
  // optional .pb.Emc_Traj_Set_G5x traj_set_g5x = 300;
  inline bool has_traj_set_g5x() const;
  inline void clear_traj_set_g5x();
  static const int kTrajSetG5XFieldNumber = 300;
  inline const ::pb::Emc_Traj_Set_G5x& traj_set_g5x() const;
  inline ::pb::Emc_Traj_Set_G5x* mutable_traj_set_g5x();
  inline ::pb::Emc_Traj_Set_G5x* release_traj_set_g5x();
  
  // optional .pb.Emc_Traj_Set_G92 traj_set_g92 = 310;
  inline bool has_traj_set_g92() const;
  inline void clear_traj_set_g92();
  static const int kTrajSetG92FieldNumber = 310;
  inline const ::pb::Emc_Traj_Set_G92& traj_set_g92() const;
  inline ::pb::Emc_Traj_Set_G92* mutable_traj_set_g92();
  inline ::pb::Emc_Traj_Set_G92* release_traj_set_g92();
  
  // optional .pb.Emc_Traj_Set_Rotation traj_set_rotation = 320;
  inline bool has_traj_set_rotation() const;
  inline void clear_traj_set_rotation();
  static const int kTrajSetRotationFieldNumber = 320;
  inline const ::pb::Emc_Traj_Set_Rotation& traj_set_rotation() const;
  inline ::pb::Emc_Traj_Set_Rotation* mutable_traj_set_rotation();
  inline ::pb::Emc_Traj_Set_Rotation* release_traj_set_rotation();
  
  // optional .pb.Emc_Traj_Linear_Move traj_linear_move = 330;
  inline bool has_traj_linear_move() const;
  inline void clear_traj_linear_move();
  static const int kTrajLinearMoveFieldNumber = 330;
  inline const ::pb::Emc_Traj_Linear_Move& traj_linear_move() const;
  inline ::pb::Emc_Traj_Linear_Move* mutable_traj_linear_move();
  inline ::pb::Emc_Traj_Linear_Move* release_traj_linear_move();
  
  // optional .pb.Emc_Traj_Probe traj_probe = 340;
  inline bool has_traj_probe() const;
  inline void clear_traj_probe();
  static const int kTrajProbeFieldNumber = 340;
  inline const ::pb::Emc_Traj_Probe& traj_probe() const;
  inline ::pb::Emc_Traj_Probe* mutable_traj_probe();
  inline ::pb::Emc_Traj_Probe* release_traj_probe();
  
  // optional .pb.Emc_Traj_Circular_Move traj_circular_move = 350;
  inline bool has_traj_circular_move() const;
  inline void clear_traj_circular_move();
  static const int kTrajCircularMoveFieldNumber = 350;
  inline const ::pb::Emc_Traj_Circular_Move& traj_circular_move() const;
  inline ::pb::Emc_Traj_Circular_Move* mutable_traj_circular_move();
  inline ::pb::Emc_Traj_Circular_Move* release_traj_circular_move();
  
  // optional .pb.Emc_Traj_Rigid_Tap traj_rigid_tap = 360;
  inline bool has_traj_rigid_tap() const;
  inline void clear_traj_rigid_tap();
  static const int kTrajRigidTapFieldNumber = 360;
  inline const ::pb::Emc_Traj_Rigid_Tap& traj_rigid_tap() const;
  inline ::pb::Emc_Traj_Rigid_Tap* mutable_traj_rigid_tap();
  inline ::pb::Emc_Traj_Rigid_Tap* release_traj_rigid_tap();
  
  // optional .pb.Emc_Traj_Set_Term_Cond traj_set_term_cond = 370;
  inline bool has_traj_set_term_cond() const;
  inline void clear_traj_set_term_cond();
  static const int kTrajSetTermCondFieldNumber = 370;
  inline const ::pb::Emc_Traj_Set_Term_Cond& traj_set_term_cond() const;
  inline ::pb::Emc_Traj_Set_Term_Cond* mutable_traj_set_term_cond();
  inline ::pb::Emc_Traj_Set_Term_Cond* release_traj_set_term_cond();
  
  // optional .pb.Emc_Traj_Set_Spindlesync traj_set_spindlesync = 380;
  inline bool has_traj_set_spindlesync() const;
  inline void clear_traj_set_spindlesync();
  static const int kTrajSetSpindlesyncFieldNumber = 380;
  inline const ::pb::Emc_Traj_Set_Spindlesync& traj_set_spindlesync() const;
  inline ::pb::Emc_Traj_Set_Spindlesync* mutable_traj_set_spindlesync();
  inline ::pb::Emc_Traj_Set_Spindlesync* release_traj_set_spindlesync();
  
  // optional .pb.Emc_Traj_Delay traj_delay = 390;
  inline bool has_traj_delay() const;
  inline void clear_traj_delay();
  static const int kTrajDelayFieldNumber = 390;
  inline const ::pb::Emc_Traj_Delay& traj_delay() const;
  inline ::pb::Emc_Traj_Delay* mutable_traj_delay();
  inline ::pb::Emc_Traj_Delay* release_traj_delay();
  
  // optional .pb.Emc_Spindle_On spindle_on = 400;
  inline bool has_spindle_on() const;
  inline void clear_spindle_on();
  static const int kSpindleOnFieldNumber = 400;
  inline const ::pb::Emc_Spindle_On& spindle_on() const;
  inline ::pb::Emc_Spindle_On* mutable_spindle_on();
  inline ::pb::Emc_Spindle_On* release_spindle_on();
  
  // optional .pb.Emc_Spindle_Speed spindle_speed = 410;
  inline bool has_spindle_speed() const;
  inline void clear_spindle_speed();
  static const int kSpindleSpeedFieldNumber = 410;
  inline const ::pb::Emc_Spindle_Speed& spindle_speed() const;
  inline ::pb::Emc_Spindle_Speed* mutable_spindle_speed();
  inline ::pb::Emc_Spindle_Speed* release_spindle_speed();
  
  // optional .pb.Emc_Spindle_Orient spindle_orient = 420;
  inline bool has_spindle_orient() const;
  inline void clear_spindle_orient();
  static const int kSpindleOrientFieldNumber = 420;
  inline const ::pb::Emc_Spindle_Orient& spindle_orient() const;
  inline ::pb::Emc_Spindle_Orient* mutable_spindle_orient();
  inline ::pb::Emc_Spindle_Orient* release_spindle_orient();
  
  // optional .pb.Emc_Spindle_Wait_Orient_Complete spindle_wait_orient_complete = 430;
  inline bool has_spindle_wait_orient_complete() const;
  inline void clear_spindle_wait_orient_complete();
  static const int kSpindleWaitOrientCompleteFieldNumber = 430;
  inline const ::pb::Emc_Spindle_Wait_Orient_Complete& spindle_wait_orient_complete() const;
  inline ::pb::Emc_Spindle_Wait_Orient_Complete* mutable_spindle_wait_orient_complete();
  inline ::pb::Emc_Spindle_Wait_Orient_Complete* release_spindle_wait_orient_complete();
  
  // optional .pb.Emc_Tool_Set_Offset tool_set_offet = 440;
  inline bool has_tool_set_offet() const;
  inline void clear_tool_set_offet();
  static const int kToolSetOffetFieldNumber = 440;
  inline const ::pb::Emc_Tool_Set_Offset& tool_set_offet() const;
  inline ::pb::Emc_Tool_Set_Offset* mutable_tool_set_offet();
  inline ::pb::Emc_Tool_Set_Offset* release_tool_set_offet();
  
  // optional .pb.Emc_Traj_Set_Offset traj_set_offset = 450;
  inline bool has_traj_set_offset() const;
  inline void clear_traj_set_offset();
  static const int kTrajSetOffsetFieldNumber = 450;
  inline const ::pb::Emc_Traj_Set_Offset& traj_set_offset() const;
  inline ::pb::Emc_Traj_Set_Offset* mutable_traj_set_offset();
  inline ::pb::Emc_Traj_Set_Offset* release_traj_set_offset();
  
  // optional .pb.Emc_Tool_Prepare tool_prepare = 460;
  inline bool has_tool_prepare() const;
  inline void clear_tool_prepare();
  static const int kToolPrepareFieldNumber = 460;
  inline const ::pb::Emc_Tool_Prepare& tool_prepare() const;
  inline ::pb::Emc_Tool_Prepare* mutable_tool_prepare();
  inline ::pb::Emc_Tool_Prepare* release_tool_prepare();
  
  // optional .pb.Emc_Tool_Set_Number tool_set_number = 470;
  inline bool has_tool_set_number() const;
  inline void clear_tool_set_number();
  static const int kToolSetNumberFieldNumber = 470;
  inline const ::pb::Emc_Tool_Set_Number& tool_set_number() const;
  inline ::pb::Emc_Tool_Set_Number* mutable_tool_set_number();
  inline ::pb::Emc_Tool_Set_Number* release_tool_set_number();
  
  // optional .pb.Emc_Traj_Set_Fo_Enable traj_set_fo_enable = 480;
  inline bool has_traj_set_fo_enable() const;
  inline void clear_traj_set_fo_enable();
  static const int kTrajSetFoEnableFieldNumber = 480;
  inline const ::pb::Emc_Traj_Set_Fo_Enable& traj_set_fo_enable() const;
  inline ::pb::Emc_Traj_Set_Fo_Enable* mutable_traj_set_fo_enable();
  inline ::pb::Emc_Traj_Set_Fo_Enable* release_traj_set_fo_enable();
  
  // optional .pb.Emc_Traj_Set_So_Enable traj_set_so_enable = 490;
  inline bool has_traj_set_so_enable() const;
  inline void clear_traj_set_so_enable();
  static const int kTrajSetSoEnableFieldNumber = 490;
  inline const ::pb::Emc_Traj_Set_So_Enable& traj_set_so_enable() const;
  inline ::pb::Emc_Traj_Set_So_Enable* mutable_traj_set_so_enable();
  inline ::pb::Emc_Traj_Set_So_Enable* release_traj_set_so_enable();
  
  // optional .pb.Emc_Traj_Set_Fh_Enable traj_set_fh_enable = 500;
  inline bool has_traj_set_fh_enable() const;
  inline void clear_traj_set_fh_enable();
  static const int kTrajSetFhEnableFieldNumber = 500;
  inline const ::pb::Emc_Traj_Set_Fh_Enable& traj_set_fh_enable() const;
  inline ::pb::Emc_Traj_Set_Fh_Enable* mutable_traj_set_fh_enable();
  inline ::pb::Emc_Traj_Set_Fh_Enable* release_traj_set_fh_enable();
  
  // optional .pb.Emc_Motion_Adaptive motion_adaptive = 510;
  inline bool has_motion_adaptive() const;
  inline void clear_motion_adaptive();
  static const int kMotionAdaptiveFieldNumber = 510;
  inline const ::pb::Emc_Motion_Adaptive& motion_adaptive() const;
  inline ::pb::Emc_Motion_Adaptive* mutable_motion_adaptive();
  inline ::pb::Emc_Motion_Adaptive* release_motion_adaptive();
  
  // optional .pb.Emc_Operator_Display operator_display = 520;
  inline bool has_operator_display() const;
  inline void clear_operator_display();
  static const int kOperatorDisplayFieldNumber = 520;
  inline const ::pb::Emc_Operator_Display& operator_display() const;
  inline ::pb::Emc_Operator_Display* mutable_operator_display();
  inline ::pb::Emc_Operator_Display* release_operator_display();
  
  // optional .pb.Emc_Operator_Text operator_text = 530;
  inline bool has_operator_text() const;
  inline void clear_operator_text();
  static const int kOperatorTextFieldNumber = 530;
  inline const ::pb::Emc_Operator_Text& operator_text() const;
  inline ::pb::Emc_Operator_Text* mutable_operator_text();
  inline ::pb::Emc_Operator_Text* release_operator_text();
  
  // optional .pb.Emc_Operator_Error operator_error = 540;
  inline bool has_operator_error() const;
  inline void clear_operator_error();
  static const int kOperatorErrorFieldNumber = 540;
  inline const ::pb::Emc_Operator_Error& operator_error() const;
  inline ::pb::Emc_Operator_Error* mutable_operator_error();
  inline ::pb::Emc_Operator_Error* release_operator_error();
  
  // optional .pb.Emc_Motion_Set_Dout motion_set_dout = 550;
  inline bool has_motion_set_dout() const;
  inline void clear_motion_set_dout();
  static const int kMotionSetDoutFieldNumber = 550;
  inline const ::pb::Emc_Motion_Set_Dout& motion_set_dout() const;
  inline ::pb::Emc_Motion_Set_Dout* mutable_motion_set_dout();
  inline ::pb::Emc_Motion_Set_Dout* release_motion_set_dout();
  
  // optional .pb.Emc_Motion_Set_Aout motion_set_aout = 560;
  inline bool has_motion_set_aout() const;
  inline void clear_motion_set_aout();
  static const int kMotionSetAoutFieldNumber = 560;
  inline const ::pb::Emc_Motion_Set_Aout& motion_set_aout() const;
  inline ::pb::Emc_Motion_Set_Aout* mutable_motion_set_aout();
  inline ::pb::Emc_Motion_Set_Aout* release_motion_set_aout();
  
  // optional .pb.Emc_Aux_Input_Wait aux_input_wait = 570;
  inline bool has_aux_input_wait() const;
  inline void clear_aux_input_wait();
  static const int kAuxInputWaitFieldNumber = 570;
  inline const ::pb::Emc_Aux_Input_Wait& aux_input_wait() const;
  inline ::pb::Emc_Aux_Input_Wait* mutable_aux_input_wait();
  inline ::pb::Emc_Aux_Input_Wait* release_aux_input_wait();
  
  // optional .pb.Emc_Exec_Plugin_Ca1l exec_plugin_call = 580;
  inline bool has_exec_plugin_call() const;
  inline void clear_exec_plugin_call();
  static const int kExecPluginCallFieldNumber = 580;
  inline const ::pb::Emc_Exec_Plugin_Ca1l& exec_plugin_call() const;
  inline ::pb::Emc_Exec_Plugin_Ca1l* mutable_exec_plugin_call();
  inline ::pb::Emc_Exec_Plugin_Ca1l* release_exec_plugin_call();
  
  // optional .pb.Emc_Io_Plugin_Call io_plugin_call = 590;
  inline bool has_io_plugin_call() const;
  inline void clear_io_plugin_call();
  static const int kIoPluginCallFieldNumber = 590;
  inline const ::pb::Emc_Io_Plugin_Call& io_plugin_call() const;
  inline ::pb::Emc_Io_Plugin_Call* mutable_io_plugin_call();
  inline ::pb::Emc_Io_Plugin_Call* release_io_plugin_call();
  
  // optional .pb.EmcStatusConfig emc_status_config = 600;
  inline bool has_emc_status_config() const;
  inline void clear_emc_status_config();
  static const int kEmcStatusConfigFieldNumber = 600;
  inline const ::pb::EmcStatusConfig& emc_status_config() const;
  inline ::pb::EmcStatusConfig* mutable_emc_status_config();
  inline ::pb::EmcStatusConfig* release_emc_status_config();
  
  // optional .pb.EmcStatusMotion emc_status_motion = 601;
  inline bool has_emc_status_motion() const;
  inline void clear_emc_status_motion();
  static const int kEmcStatusMotionFieldNumber = 601;
  inline const ::pb::EmcStatusMotion& emc_status_motion() const;
  inline ::pb::EmcStatusMotion* mutable_emc_status_motion();
  inline ::pb::EmcStatusMotion* release_emc_status_motion();
  
  // optional .pb.EmcStatusIo emc_status_io = 602;
  inline bool has_emc_status_io() const;
  inline void clear_emc_status_io();
  static const int kEmcStatusIoFieldNumber = 602;
  inline const ::pb::EmcStatusIo& emc_status_io() const;
  inline ::pb::EmcStatusIo* mutable_emc_status_io();
  inline ::pb::EmcStatusIo* release_emc_status_io();
  
  // optional .pb.EmcStatusTask emc_status_task = 603;
  inline bool has_emc_status_task() const;
  inline void clear_emc_status_task();
  static const int kEmcStatusTaskFieldNumber = 603;
  inline const ::pb::EmcStatusTask& emc_status_task() const;
  inline ::pb::EmcStatusTask* mutable_emc_status_task();
  inline ::pb::EmcStatusTask* release_emc_status_task();
  
  // optional .pb.EmcStatusInterp emc_status_interp = 604;
  inline bool has_emc_status_interp() const;
  inline void clear_emc_status_interp();
  static const int kEmcStatusInterpFieldNumber = 604;
  inline const ::pb::EmcStatusInterp& emc_status_interp() const;
  inline ::pb::EmcStatusInterp* mutable_emc_status_interp();
  inline ::pb::EmcStatusInterp* release_emc_status_interp();
  
  // optional .pb.EmcCommandParameters emc_command_params = 610;
  inline bool has_emc_command_params() const;
  inline void clear_emc_command_params();
  static const int kEmcCommandParamsFieldNumber = 610;
  inline const ::pb::EmcCommandParameters& emc_command_params() const;
  inline ::pb::EmcCommandParameters* mutable_emc_command_params();
  inline ::pb::EmcCommandParameters* release_emc_command_params();
  
  // @@protoc_insertion_point(class_scope:pb.Container)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_tsc();
  inline void clear_has_tsc();
  inline void set_has_motcmd();
  inline void clear_has_motcmd();
  inline void set_has_motstat();
  inline void clear_has_motstat();
  inline void set_has_legacy_motcmd();
  inline void clear_has_legacy_motcmd();
  inline void set_has_legacy_motstat();
  inline void clear_has_legacy_motstat();
  inline void set_has_rtapi_message();
  inline void clear_has_rtapi_message();
  inline void set_has_task_reply();
  inline void clear_has_task_reply();
  inline void set_has_ticket_update();
  inline void clear_has_ticket_update();
  inline void set_has_syslog();
  inline void clear_has_syslog();
  inline void set_has_legacy_nml();
  inline void clear_has_legacy_nml();
  inline void set_has_legacy_motconfig();
  inline void clear_has_legacy_motconfig();
  inline void set_has_tv_sec();
  inline void clear_has_tv_sec();
  inline void set_has_tv_nsec();
  inline void clear_has_tv_nsec();
  inline void set_has_topic();
  inline void clear_has_topic();
  inline void set_has_reply_required();
  inline void clear_has_reply_required();
  inline void set_has_interp_state();
  inline void clear_has_interp_state();
  inline void set_has_interp_name();
  inline void clear_has_interp_name();
  inline void set_has_rsvp();
  inline void clear_has_rsvp();
  inline void set_has_in_reply_to();
  inline void clear_has_in_reply_to();
  inline void set_has_rcs_status();
  inline void clear_has_rcs_status();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_serial();
  inline void clear_has_serial();
  inline void set_has_reply_serial();
  inline void clear_has_reply_serial();
  inline void set_has_ticket();
  inline void clear_has_ticket();
  inline void set_has_reply_ticket();
  inline void clear_has_reply_ticket();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_credit();
  inline void clear_has_credit();
  inline void set_has_line_number();
  inline void clear_has_line_number();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_retcode();
  inline void clear_has_retcode();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_trace();
  inline void clear_has_trace();
  inline void set_has_instance();
  inline void clear_has_instance();
  inline void set_has_rtapicmd();
  inline void clear_has_rtapicmd();
  inline void set_has_pparams();
  inline void clear_has_pparams();
  inline void set_has_log_message();
  inline void clear_has_log_message();
  inline void set_has_tpexecute();
  inline void clear_has_tpexecute();
  inline void set_has_tpblockdelete();
  inline void clear_has_tpblockdelete();
  inline void set_has_tpoptionalstop();
  inline void clear_has_tpoptionalstop();
  inline void set_has_tpopen();
  inline void clear_has_tpopen();
  inline void set_has_taskplan_reply();
  inline void clear_has_taskplan_reply();
  inline void set_has_traj_set_g5x();
  inline void clear_has_traj_set_g5x();
  inline void set_has_traj_set_g92();
  inline void clear_has_traj_set_g92();
  inline void set_has_traj_set_rotation();
  inline void clear_has_traj_set_rotation();
  inline void set_has_traj_linear_move();
  inline void clear_has_traj_linear_move();
  inline void set_has_traj_probe();
  inline void clear_has_traj_probe();
  inline void set_has_traj_circular_move();
  inline void clear_has_traj_circular_move();
  inline void set_has_traj_rigid_tap();
  inline void clear_has_traj_rigid_tap();
  inline void set_has_traj_set_term_cond();
  inline void clear_has_traj_set_term_cond();
  inline void set_has_traj_set_spindlesync();
  inline void clear_has_traj_set_spindlesync();
  inline void set_has_traj_delay();
  inline void clear_has_traj_delay();
  inline void set_has_spindle_on();
  inline void clear_has_spindle_on();
  inline void set_has_spindle_speed();
  inline void clear_has_spindle_speed();
  inline void set_has_spindle_orient();
  inline void clear_has_spindle_orient();
  inline void set_has_spindle_wait_orient_complete();
  inline void clear_has_spindle_wait_orient_complete();
  inline void set_has_tool_set_offet();
  inline void clear_has_tool_set_offet();
  inline void set_has_traj_set_offset();
  inline void clear_has_traj_set_offset();
  inline void set_has_tool_prepare();
  inline void clear_has_tool_prepare();
  inline void set_has_tool_set_number();
  inline void clear_has_tool_set_number();
  inline void set_has_traj_set_fo_enable();
  inline void clear_has_traj_set_fo_enable();
  inline void set_has_traj_set_so_enable();
  inline void clear_has_traj_set_so_enable();
  inline void set_has_traj_set_fh_enable();
  inline void clear_has_traj_set_fh_enable();
  inline void set_has_motion_adaptive();
  inline void clear_has_motion_adaptive();
  inline void set_has_operator_display();
  inline void clear_has_operator_display();
  inline void set_has_operator_text();
  inline void clear_has_operator_text();
  inline void set_has_operator_error();
  inline void clear_has_operator_error();
  inline void set_has_motion_set_dout();
  inline void clear_has_motion_set_dout();
  inline void set_has_motion_set_aout();
  inline void clear_has_motion_set_aout();
  inline void set_has_aux_input_wait();
  inline void clear_has_aux_input_wait();
  inline void set_has_exec_plugin_call();
  inline void clear_has_exec_plugin_call();
  inline void set_has_io_plugin_call();
  inline void clear_has_io_plugin_call();
  inline void set_has_emc_status_config();
  inline void clear_has_emc_status_config();
  inline void set_has_emc_status_motion();
  inline void clear_has_emc_status_motion();
  inline void set_has_emc_status_io();
  inline void clear_has_emc_status_io();
  inline void set_has_emc_status_task();
  inline void clear_has_emc_status_task();
  inline void set_has_emc_status_interp();
  inline void clear_has_emc_status_interp();
  inline void set_has_emc_command_params();
  inline void clear_has_emc_command_params();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 tsc_;
  ::google::protobuf::RepeatedPtrField< ::pb::Preview > preview_;
  ::pb::MotionCommand* motcmd_;
  ::pb::MotionStatus* motstat_;
  ::std::string* legacy_motcmd_;
  ::std::string* legacy_motstat_;
  int type_;
  ::google::protobuf::int32 tv_sec_;
  ::pb::RTAPI_Message* rtapi_message_;
  ::pb::TaskReply* task_reply_;
  ::pb::TicketUpdate* ticket_update_;
  ::std::string* syslog_;
  ::std::string* legacy_nml_;
  ::std::string* legacy_motconfig_;
  ::std::string* topic_;
  ::google::protobuf::int32 tv_nsec_;
  int interp_state_;
  ::std::string* interp_name_;
  ::google::protobuf::int32 rsvp_;
  int in_reply_to_;
  int rcs_status_;
  int status_;
  ::google::protobuf::int32 serial_;
  ::google::protobuf::int32 reply_serial_;
  ::google::protobuf::int32 ticket_;
  bool reply_required_;
  bool trace_;
  ::google::protobuf::int32 reply_ticket_;
  ::google::protobuf::int32 sequence_;
  ::google::protobuf::int32 credit_;
  ::google::protobuf::int32 line_number_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> note_;
  ::std::string* uuid_;
  ::google::protobuf::int32 retcode_;
  ::google::protobuf::int32 instance_;
  ::google::protobuf::RepeatedPtrField< ::pb::Value > value_;
  ::pb::RTAPICommand* rtapicmd_;
  ::google::protobuf::RepeatedPtrField< ::pb::ServiceAnnouncement > service_announcement_;
  ::google::protobuf::RepeatedPtrField< ::pb::Component > comp_;
  ::google::protobuf::RepeatedPtrField< ::pb::Pin > pin_;
  ::google::protobuf::RepeatedPtrField< ::pb::Signal > signal_;
  ::google::protobuf::RepeatedPtrField< ::pb::Param > param_;
  ::google::protobuf::RepeatedPtrField< ::pb::Thread > thread_;
  ::google::protobuf::RepeatedPtrField< ::pb::Ring > ring_;
  ::google::protobuf::RepeatedPtrField< ::pb::Group > group_;
  ::google::protobuf::RepeatedPtrField< ::pb::Member > member_;
  ::google::protobuf::RepeatedPtrField< ::pb::Function > function_;
  ::pb::ProtocolParameters* pparams_;
  ::google::protobuf::RepeatedPtrField< ::pb::Application > app_;
  ::pb::LogMessage* log_message_;
  ::pb::TaskPlanExecute* tpexecute_;
  ::pb::TaskPlanBlockDelete* tpblockdelete_;
  ::pb::TaskPlanOptionalStop* tpoptionalstop_;
  ::pb::TaskPlanOpen* tpopen_;
  ::pb::TaskPlanReply* taskplan_reply_;
  ::pb::Emc_Traj_Set_G5x* traj_set_g5x_;
  ::pb::Emc_Traj_Set_G92* traj_set_g92_;
  ::pb::Emc_Traj_Set_Rotation* traj_set_rotation_;
  ::pb::Emc_Traj_Linear_Move* traj_linear_move_;
  ::pb::Emc_Traj_Probe* traj_probe_;
  ::pb::Emc_Traj_Circular_Move* traj_circular_move_;
  ::pb::Emc_Traj_Rigid_Tap* traj_rigid_tap_;
  ::pb::Emc_Traj_Set_Term_Cond* traj_set_term_cond_;
  ::pb::Emc_Traj_Set_Spindlesync* traj_set_spindlesync_;
  ::pb::Emc_Traj_Delay* traj_delay_;
  ::pb::Emc_Spindle_On* spindle_on_;
  ::pb::Emc_Spindle_Speed* spindle_speed_;
  ::pb::Emc_Spindle_Orient* spindle_orient_;
  ::pb::Emc_Spindle_Wait_Orient_Complete* spindle_wait_orient_complete_;
  ::pb::Emc_Tool_Set_Offset* tool_set_offet_;
  ::pb::Emc_Traj_Set_Offset* traj_set_offset_;
  ::pb::Emc_Tool_Prepare* tool_prepare_;
  ::pb::Emc_Tool_Set_Number* tool_set_number_;
  ::pb::Emc_Traj_Set_Fo_Enable* traj_set_fo_enable_;
  ::pb::Emc_Traj_Set_So_Enable* traj_set_so_enable_;
  ::pb::Emc_Traj_Set_Fh_Enable* traj_set_fh_enable_;
  ::pb::Emc_Motion_Adaptive* motion_adaptive_;
  ::pb::Emc_Operator_Display* operator_display_;
  ::pb::Emc_Operator_Text* operator_text_;
  ::pb::Emc_Operator_Error* operator_error_;
  ::pb::Emc_Motion_Set_Dout* motion_set_dout_;
  ::pb::Emc_Motion_Set_Aout* motion_set_aout_;
  ::pb::Emc_Aux_Input_Wait* aux_input_wait_;
  ::pb::Emc_Exec_Plugin_Ca1l* exec_plugin_call_;
  ::pb::Emc_Io_Plugin_Call* io_plugin_call_;
  ::pb::EmcStatusConfig* emc_status_config_;
  ::pb::EmcStatusMotion* emc_status_motion_;
  ::pb::EmcStatusIo* emc_status_io_;
  ::pb::EmcStatusTask* emc_status_task_;
  ::pb::EmcStatusInterp* emc_status_interp_;
  ::pb::EmcCommandParameters* emc_command_params_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(92 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static Container* default_instance_;
};
// ===================================================================


// ===================================================================

// Container

// required .pb.ContainerType type = 1;
inline bool Container::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Container::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Container::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Container::clear_type() {
  type_ = 2;
  clear_has_type();
}
inline pb::ContainerType Container::type() const {
  return static_cast< pb::ContainerType >(type_);
}
inline void Container::set_type(pb::ContainerType value) {
  GOOGLE_DCHECK(pb::ContainerType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional sfixed64 tsc = 7;
inline bool Container::has_tsc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Container::set_has_tsc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Container::clear_has_tsc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Container::clear_tsc() {
  tsc_ = GOOGLE_LONGLONG(0);
  clear_has_tsc();
}
inline ::google::protobuf::int64 Container::tsc() const {
  return tsc_;
}
inline void Container::set_tsc(::google::protobuf::int64 value) {
  set_has_tsc();
  tsc_ = value;
}

// repeated .pb.Preview preview = 8;
inline int Container::preview_size() const {
  return preview_.size();
}
inline void Container::clear_preview() {
  preview_.Clear();
}
inline const ::pb::Preview& Container::preview(int index) const {
  return preview_.Get(index);
}
inline ::pb::Preview* Container::mutable_preview(int index) {
  return preview_.Mutable(index);
}
inline ::pb::Preview* Container::add_preview() {
  return preview_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Preview >&
Container::preview() const {
  return preview_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Preview >*
Container::mutable_preview() {
  return &preview_;
}

// optional .pb.MotionCommand motcmd = 9;
inline bool Container::has_motcmd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Container::set_has_motcmd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Container::clear_has_motcmd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Container::clear_motcmd() {
  if (motcmd_ != NULL) motcmd_->::pb::MotionCommand::Clear();
  clear_has_motcmd();
}
inline const ::pb::MotionCommand& Container::motcmd() const {
  return motcmd_ != NULL ? *motcmd_ : *default_instance_->motcmd_;
}
inline ::pb::MotionCommand* Container::mutable_motcmd() {
  set_has_motcmd();
  if (motcmd_ == NULL) motcmd_ = new ::pb::MotionCommand;
  return motcmd_;
}
inline ::pb::MotionCommand* Container::release_motcmd() {
  clear_has_motcmd();
  ::pb::MotionCommand* temp = motcmd_;
  motcmd_ = NULL;
  return temp;
}

// optional .pb.MotionStatus motstat = 10;
inline bool Container::has_motstat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Container::set_has_motstat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Container::clear_has_motstat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Container::clear_motstat() {
  if (motstat_ != NULL) motstat_->::pb::MotionStatus::Clear();
  clear_has_motstat();
}
inline const ::pb::MotionStatus& Container::motstat() const {
  return motstat_ != NULL ? *motstat_ : *default_instance_->motstat_;
}
inline ::pb::MotionStatus* Container::mutable_motstat() {
  set_has_motstat();
  if (motstat_ == NULL) motstat_ = new ::pb::MotionStatus;
  return motstat_;
}
inline ::pb::MotionStatus* Container::release_motstat() {
  clear_has_motstat();
  ::pb::MotionStatus* temp = motstat_;
  motstat_ = NULL;
  return temp;
}

// optional bytes legacy_motcmd = 11;
inline bool Container::has_legacy_motcmd() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Container::set_has_legacy_motcmd() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Container::clear_has_legacy_motcmd() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Container::clear_legacy_motcmd() {
  if (legacy_motcmd_ != &::google::protobuf::internal::kEmptyString) {
    legacy_motcmd_->clear();
  }
  clear_has_legacy_motcmd();
}
inline const ::std::string& Container::legacy_motcmd() const {
  return *legacy_motcmd_;
}
inline void Container::set_legacy_motcmd(const ::std::string& value) {
  set_has_legacy_motcmd();
  if (legacy_motcmd_ == &::google::protobuf::internal::kEmptyString) {
    legacy_motcmd_ = new ::std::string;
  }
  legacy_motcmd_->assign(value);
}
inline void Container::set_legacy_motcmd(const char* value) {
  set_has_legacy_motcmd();
  if (legacy_motcmd_ == &::google::protobuf::internal::kEmptyString) {
    legacy_motcmd_ = new ::std::string;
  }
  legacy_motcmd_->assign(value);
}
inline void Container::set_legacy_motcmd(const void* value, size_t size) {
  set_has_legacy_motcmd();
  if (legacy_motcmd_ == &::google::protobuf::internal::kEmptyString) {
    legacy_motcmd_ = new ::std::string;
  }
  legacy_motcmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_legacy_motcmd() {
  set_has_legacy_motcmd();
  if (legacy_motcmd_ == &::google::protobuf::internal::kEmptyString) {
    legacy_motcmd_ = new ::std::string;
  }
  return legacy_motcmd_;
}
inline ::std::string* Container::release_legacy_motcmd() {
  clear_has_legacy_motcmd();
  if (legacy_motcmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = legacy_motcmd_;
    legacy_motcmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes legacy_motstat = 12;
inline bool Container::has_legacy_motstat() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Container::set_has_legacy_motstat() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Container::clear_has_legacy_motstat() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Container::clear_legacy_motstat() {
  if (legacy_motstat_ != &::google::protobuf::internal::kEmptyString) {
    legacy_motstat_->clear();
  }
  clear_has_legacy_motstat();
}
inline const ::std::string& Container::legacy_motstat() const {
  return *legacy_motstat_;
}
inline void Container::set_legacy_motstat(const ::std::string& value) {
  set_has_legacy_motstat();
  if (legacy_motstat_ == &::google::protobuf::internal::kEmptyString) {
    legacy_motstat_ = new ::std::string;
  }
  legacy_motstat_->assign(value);
}
inline void Container::set_legacy_motstat(const char* value) {
  set_has_legacy_motstat();
  if (legacy_motstat_ == &::google::protobuf::internal::kEmptyString) {
    legacy_motstat_ = new ::std::string;
  }
  legacy_motstat_->assign(value);
}
inline void Container::set_legacy_motstat(const void* value, size_t size) {
  set_has_legacy_motstat();
  if (legacy_motstat_ == &::google::protobuf::internal::kEmptyString) {
    legacy_motstat_ = new ::std::string;
  }
  legacy_motstat_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_legacy_motstat() {
  set_has_legacy_motstat();
  if (legacy_motstat_ == &::google::protobuf::internal::kEmptyString) {
    legacy_motstat_ = new ::std::string;
  }
  return legacy_motstat_;
}
inline ::std::string* Container::release_legacy_motstat() {
  clear_has_legacy_motstat();
  if (legacy_motstat_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = legacy_motstat_;
    legacy_motstat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .pb.RTAPI_Message rtapi_message = 13;
inline bool Container::has_rtapi_message() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Container::set_has_rtapi_message() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Container::clear_has_rtapi_message() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Container::clear_rtapi_message() {
  if (rtapi_message_ != NULL) rtapi_message_->::pb::RTAPI_Message::Clear();
  clear_has_rtapi_message();
}
inline const ::pb::RTAPI_Message& Container::rtapi_message() const {
  return rtapi_message_ != NULL ? *rtapi_message_ : *default_instance_->rtapi_message_;
}
inline ::pb::RTAPI_Message* Container::mutable_rtapi_message() {
  set_has_rtapi_message();
  if (rtapi_message_ == NULL) rtapi_message_ = new ::pb::RTAPI_Message;
  return rtapi_message_;
}
inline ::pb::RTAPI_Message* Container::release_rtapi_message() {
  clear_has_rtapi_message();
  ::pb::RTAPI_Message* temp = rtapi_message_;
  rtapi_message_ = NULL;
  return temp;
}

// optional .pb.TaskReply task_reply = 14;
inline bool Container::has_task_reply() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Container::set_has_task_reply() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Container::clear_has_task_reply() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Container::clear_task_reply() {
  if (task_reply_ != NULL) task_reply_->::pb::TaskReply::Clear();
  clear_has_task_reply();
}
inline const ::pb::TaskReply& Container::task_reply() const {
  return task_reply_ != NULL ? *task_reply_ : *default_instance_->task_reply_;
}
inline ::pb::TaskReply* Container::mutable_task_reply() {
  set_has_task_reply();
  if (task_reply_ == NULL) task_reply_ = new ::pb::TaskReply;
  return task_reply_;
}
inline ::pb::TaskReply* Container::release_task_reply() {
  clear_has_task_reply();
  ::pb::TaskReply* temp = task_reply_;
  task_reply_ = NULL;
  return temp;
}

// optional .pb.TicketUpdate ticket_update = 15;
inline bool Container::has_ticket_update() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Container::set_has_ticket_update() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Container::clear_has_ticket_update() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Container::clear_ticket_update() {
  if (ticket_update_ != NULL) ticket_update_->::pb::TicketUpdate::Clear();
  clear_has_ticket_update();
}
inline const ::pb::TicketUpdate& Container::ticket_update() const {
  return ticket_update_ != NULL ? *ticket_update_ : *default_instance_->ticket_update_;
}
inline ::pb::TicketUpdate* Container::mutable_ticket_update() {
  set_has_ticket_update();
  if (ticket_update_ == NULL) ticket_update_ = new ::pb::TicketUpdate;
  return ticket_update_;
}
inline ::pb::TicketUpdate* Container::release_ticket_update() {
  clear_has_ticket_update();
  ::pb::TicketUpdate* temp = ticket_update_;
  ticket_update_ = NULL;
  return temp;
}

// optional bytes syslog = 18;
inline bool Container::has_syslog() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Container::set_has_syslog() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Container::clear_has_syslog() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Container::clear_syslog() {
  if (syslog_ != &::google::protobuf::internal::kEmptyString) {
    syslog_->clear();
  }
  clear_has_syslog();
}
inline const ::std::string& Container::syslog() const {
  return *syslog_;
}
inline void Container::set_syslog(const ::std::string& value) {
  set_has_syslog();
  if (syslog_ == &::google::protobuf::internal::kEmptyString) {
    syslog_ = new ::std::string;
  }
  syslog_->assign(value);
}
inline void Container::set_syslog(const char* value) {
  set_has_syslog();
  if (syslog_ == &::google::protobuf::internal::kEmptyString) {
    syslog_ = new ::std::string;
  }
  syslog_->assign(value);
}
inline void Container::set_syslog(const void* value, size_t size) {
  set_has_syslog();
  if (syslog_ == &::google::protobuf::internal::kEmptyString) {
    syslog_ = new ::std::string;
  }
  syslog_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_syslog() {
  set_has_syslog();
  if (syslog_ == &::google::protobuf::internal::kEmptyString) {
    syslog_ = new ::std::string;
  }
  return syslog_;
}
inline ::std::string* Container::release_syslog() {
  clear_has_syslog();
  if (syslog_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = syslog_;
    syslog_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes legacy_nml = 19;
inline bool Container::has_legacy_nml() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Container::set_has_legacy_nml() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Container::clear_has_legacy_nml() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Container::clear_legacy_nml() {
  if (legacy_nml_ != &::google::protobuf::internal::kEmptyString) {
    legacy_nml_->clear();
  }
  clear_has_legacy_nml();
}
inline const ::std::string& Container::legacy_nml() const {
  return *legacy_nml_;
}
inline void Container::set_legacy_nml(const ::std::string& value) {
  set_has_legacy_nml();
  if (legacy_nml_ == &::google::protobuf::internal::kEmptyString) {
    legacy_nml_ = new ::std::string;
  }
  legacy_nml_->assign(value);
}
inline void Container::set_legacy_nml(const char* value) {
  set_has_legacy_nml();
  if (legacy_nml_ == &::google::protobuf::internal::kEmptyString) {
    legacy_nml_ = new ::std::string;
  }
  legacy_nml_->assign(value);
}
inline void Container::set_legacy_nml(const void* value, size_t size) {
  set_has_legacy_nml();
  if (legacy_nml_ == &::google::protobuf::internal::kEmptyString) {
    legacy_nml_ = new ::std::string;
  }
  legacy_nml_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_legacy_nml() {
  set_has_legacy_nml();
  if (legacy_nml_ == &::google::protobuf::internal::kEmptyString) {
    legacy_nml_ = new ::std::string;
  }
  return legacy_nml_;
}
inline ::std::string* Container::release_legacy_nml() {
  clear_has_legacy_nml();
  if (legacy_nml_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = legacy_nml_;
    legacy_nml_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes legacy_motconfig = 20;
inline bool Container::has_legacy_motconfig() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Container::set_has_legacy_motconfig() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Container::clear_has_legacy_motconfig() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Container::clear_legacy_motconfig() {
  if (legacy_motconfig_ != &::google::protobuf::internal::kEmptyString) {
    legacy_motconfig_->clear();
  }
  clear_has_legacy_motconfig();
}
inline const ::std::string& Container::legacy_motconfig() const {
  return *legacy_motconfig_;
}
inline void Container::set_legacy_motconfig(const ::std::string& value) {
  set_has_legacy_motconfig();
  if (legacy_motconfig_ == &::google::protobuf::internal::kEmptyString) {
    legacy_motconfig_ = new ::std::string;
  }
  legacy_motconfig_->assign(value);
}
inline void Container::set_legacy_motconfig(const char* value) {
  set_has_legacy_motconfig();
  if (legacy_motconfig_ == &::google::protobuf::internal::kEmptyString) {
    legacy_motconfig_ = new ::std::string;
  }
  legacy_motconfig_->assign(value);
}
inline void Container::set_legacy_motconfig(const void* value, size_t size) {
  set_has_legacy_motconfig();
  if (legacy_motconfig_ == &::google::protobuf::internal::kEmptyString) {
    legacy_motconfig_ = new ::std::string;
  }
  legacy_motconfig_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_legacy_motconfig() {
  set_has_legacy_motconfig();
  if (legacy_motconfig_ == &::google::protobuf::internal::kEmptyString) {
    legacy_motconfig_ = new ::std::string;
  }
  return legacy_motconfig_;
}
inline ::std::string* Container::release_legacy_motconfig() {
  clear_has_legacy_motconfig();
  if (legacy_motconfig_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = legacy_motconfig_;
    legacy_motconfig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 tv_sec = 21;
inline bool Container::has_tv_sec() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Container::set_has_tv_sec() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Container::clear_has_tv_sec() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Container::clear_tv_sec() {
  tv_sec_ = 0;
  clear_has_tv_sec();
}
inline ::google::protobuf::int32 Container::tv_sec() const {
  return tv_sec_;
}
inline void Container::set_tv_sec(::google::protobuf::int32 value) {
  set_has_tv_sec();
  tv_sec_ = value;
}

// optional int32 tv_nsec = 22;
inline bool Container::has_tv_nsec() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Container::set_has_tv_nsec() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Container::clear_has_tv_nsec() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Container::clear_tv_nsec() {
  tv_nsec_ = 0;
  clear_has_tv_nsec();
}
inline ::google::protobuf::int32 Container::tv_nsec() const {
  return tv_nsec_;
}
inline void Container::set_tv_nsec(::google::protobuf::int32 value) {
  set_has_tv_nsec();
  tv_nsec_ = value;
}

// optional string topic = 23;
inline bool Container::has_topic() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Container::set_has_topic() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Container::clear_has_topic() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Container::clear_topic() {
  if (topic_ != &::google::protobuf::internal::kEmptyString) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& Container::topic() const {
  return *topic_;
}
inline void Container::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
}
inline void Container::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
}
inline void Container::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    topic_ = new ::std::string;
  }
  return topic_;
}
inline ::std::string* Container::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool reply_required = 24;
inline bool Container::has_reply_required() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Container::set_has_reply_required() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Container::clear_has_reply_required() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Container::clear_reply_required() {
  reply_required_ = false;
  clear_has_reply_required();
}
inline bool Container::reply_required() const {
  return reply_required_;
}
inline void Container::set_reply_required(bool value) {
  set_has_reply_required();
  reply_required_ = value;
}

// optional .pb.InterpreterStateType interp_state = 25;
inline bool Container::has_interp_state() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Container::set_has_interp_state() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Container::clear_has_interp_state() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Container::clear_interp_state() {
  interp_state_ = 1;
  clear_has_interp_state();
}
inline pb::InterpreterStateType Container::interp_state() const {
  return static_cast< pb::InterpreterStateType >(interp_state_);
}
inline void Container::set_interp_state(pb::InterpreterStateType value) {
  GOOGLE_DCHECK(pb::InterpreterStateType_IsValid(value));
  set_has_interp_state();
  interp_state_ = value;
}

// optional string interp_name = 26;
inline bool Container::has_interp_name() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Container::set_has_interp_name() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Container::clear_has_interp_name() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Container::clear_interp_name() {
  if (interp_name_ != &::google::protobuf::internal::kEmptyString) {
    interp_name_->clear();
  }
  clear_has_interp_name();
}
inline const ::std::string& Container::interp_name() const {
  return *interp_name_;
}
inline void Container::set_interp_name(const ::std::string& value) {
  set_has_interp_name();
  if (interp_name_ == &::google::protobuf::internal::kEmptyString) {
    interp_name_ = new ::std::string;
  }
  interp_name_->assign(value);
}
inline void Container::set_interp_name(const char* value) {
  set_has_interp_name();
  if (interp_name_ == &::google::protobuf::internal::kEmptyString) {
    interp_name_ = new ::std::string;
  }
  interp_name_->assign(value);
}
inline void Container::set_interp_name(const char* value, size_t size) {
  set_has_interp_name();
  if (interp_name_ == &::google::protobuf::internal::kEmptyString) {
    interp_name_ = new ::std::string;
  }
  interp_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_interp_name() {
  set_has_interp_name();
  if (interp_name_ == &::google::protobuf::internal::kEmptyString) {
    interp_name_ = new ::std::string;
  }
  return interp_name_;
}
inline ::std::string* Container::release_interp_name() {
  clear_has_interp_name();
  if (interp_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = interp_name_;
    interp_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 rsvp = 30;
inline bool Container::has_rsvp() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Container::set_has_rsvp() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Container::clear_has_rsvp() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Container::clear_rsvp() {
  rsvp_ = 0;
  clear_has_rsvp();
}
inline ::google::protobuf::int32 Container::rsvp() const {
  return rsvp_;
}
inline void Container::set_rsvp(::google::protobuf::int32 value) {
  set_has_rsvp();
  rsvp_ = value;
}

// optional .pb.ContainerType in_reply_to = 33;
inline bool Container::has_in_reply_to() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Container::set_has_in_reply_to() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Container::clear_has_in_reply_to() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Container::clear_in_reply_to() {
  in_reply_to_ = 2;
  clear_has_in_reply_to();
}
inline pb::ContainerType Container::in_reply_to() const {
  return static_cast< pb::ContainerType >(in_reply_to_);
}
inline void Container::set_in_reply_to(pb::ContainerType value) {
  GOOGLE_DCHECK(pb::ContainerType_IsValid(value));
  set_has_in_reply_to();
  in_reply_to_ = value;
}

// optional .pb.RCS_STATUS rcs_status = 35;
inline bool Container::has_rcs_status() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Container::set_has_rcs_status() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Container::clear_has_rcs_status() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Container::clear_rcs_status() {
  rcs_status_ = -1;
  clear_has_rcs_status();
}
inline pb::RCS_STATUS Container::rcs_status() const {
  return static_cast< pb::RCS_STATUS >(rcs_status_);
}
inline void Container::set_rcs_status(pb::RCS_STATUS value) {
  GOOGLE_DCHECK(pb::RCS_STATUS_IsValid(value));
  set_has_rcs_status();
  rcs_status_ = value;
}

// optional .pb.StatusType status = 40;
inline bool Container::has_status() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Container::set_has_status() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Container::clear_has_status() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Container::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline pb::StatusType Container::status() const {
  return static_cast< pb::StatusType >(status_);
}
inline void Container::set_status(pb::StatusType value) {
  GOOGLE_DCHECK(pb::StatusType_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional int32 serial = 45;
inline bool Container::has_serial() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Container::set_has_serial() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Container::clear_has_serial() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Container::clear_serial() {
  serial_ = 0;
  clear_has_serial();
}
inline ::google::protobuf::int32 Container::serial() const {
  return serial_;
}
inline void Container::set_serial(::google::protobuf::int32 value) {
  set_has_serial();
  serial_ = value;
}

// optional int32 reply_serial = 50;
inline bool Container::has_reply_serial() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Container::set_has_reply_serial() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Container::clear_has_reply_serial() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Container::clear_reply_serial() {
  reply_serial_ = 0;
  clear_has_reply_serial();
}
inline ::google::protobuf::int32 Container::reply_serial() const {
  return reply_serial_;
}
inline void Container::set_reply_serial(::google::protobuf::int32 value) {
  set_has_reply_serial();
  reply_serial_ = value;
}

// optional int32 ticket = 55;
inline bool Container::has_ticket() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Container::set_has_ticket() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Container::clear_has_ticket() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Container::clear_ticket() {
  ticket_ = 0;
  clear_has_ticket();
}
inline ::google::protobuf::int32 Container::ticket() const {
  return ticket_;
}
inline void Container::set_ticket(::google::protobuf::int32 value) {
  set_has_ticket();
  ticket_ = value;
}

// optional int32 reply_ticket = 60;
inline bool Container::has_reply_ticket() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Container::set_has_reply_ticket() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Container::clear_has_reply_ticket() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Container::clear_reply_ticket() {
  reply_ticket_ = 0;
  clear_has_reply_ticket();
}
inline ::google::protobuf::int32 Container::reply_ticket() const {
  return reply_ticket_;
}
inline void Container::set_reply_ticket(::google::protobuf::int32 value) {
  set_has_reply_ticket();
  reply_ticket_ = value;
}

// optional int32 sequence = 62;
inline bool Container::has_sequence() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Container::set_has_sequence() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Container::clear_has_sequence() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Container::clear_sequence() {
  sequence_ = 0;
  clear_has_sequence();
}
inline ::google::protobuf::int32 Container::sequence() const {
  return sequence_;
}
inline void Container::set_sequence(::google::protobuf::int32 value) {
  set_has_sequence();
  sequence_ = value;
}

// optional int32 credit = 65;
inline bool Container::has_credit() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Container::set_has_credit() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Container::clear_has_credit() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Container::clear_credit() {
  credit_ = 0;
  clear_has_credit();
}
inline ::google::protobuf::int32 Container::credit() const {
  return credit_;
}
inline void Container::set_credit(::google::protobuf::int32 value) {
  set_has_credit();
  credit_ = value;
}

// optional int32 line_number = 66;
inline bool Container::has_line_number() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Container::set_has_line_number() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Container::clear_has_line_number() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Container::clear_line_number() {
  line_number_ = 0;
  clear_has_line_number();
}
inline ::google::protobuf::int32 Container::line_number() const {
  return line_number_;
}
inline void Container::set_line_number(::google::protobuf::int32 value) {
  set_has_line_number();
  line_number_ = value;
}

// optional string name = 67;
inline bool Container::has_name() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Container::set_has_name() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Container::clear_has_name() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Container::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Container::name() const {
  return *name_;
}
inline void Container::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Container::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Container::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Container::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string note = 68;
inline int Container::note_size() const {
  return note_.size();
}
inline void Container::clear_note() {
  note_.Clear();
}
inline const ::std::string& Container::note(int index) const {
  return note_.Get(index);
}
inline ::std::string* Container::mutable_note(int index) {
  return note_.Mutable(index);
}
inline void Container::set_note(int index, const ::std::string& value) {
  note_.Mutable(index)->assign(value);
}
inline void Container::set_note(int index, const char* value) {
  note_.Mutable(index)->assign(value);
}
inline void Container::set_note(int index, const char* value, size_t size) {
  note_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::add_note() {
  return note_.Add();
}
inline void Container::add_note(const ::std::string& value) {
  note_.Add()->assign(value);
}
inline void Container::add_note(const char* value) {
  note_.Add()->assign(value);
}
inline void Container::add_note(const char* value, size_t size) {
  note_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Container::note() const {
  return note_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Container::mutable_note() {
  return &note_;
}

// optional int32 retcode = 69;
inline bool Container::has_retcode() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void Container::set_has_retcode() {
  _has_bits_[1] |= 0x00000001u;
}
inline void Container::clear_has_retcode() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void Container::clear_retcode() {
  retcode_ = 0;
  clear_has_retcode();
}
inline ::google::protobuf::int32 Container::retcode() const {
  return retcode_;
}
inline void Container::set_retcode(::google::protobuf::int32 value) {
  set_has_retcode();
  retcode_ = value;
}

// optional bytes uuid = 72;
inline bool Container::has_uuid() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void Container::set_has_uuid() {
  _has_bits_[1] |= 0x00000002u;
}
inline void Container::clear_has_uuid() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void Container::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& Container::uuid() const {
  return *uuid_;
}
inline void Container::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void Container::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void Container::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* Container::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool trace = 75;
inline bool Container::has_trace() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void Container::set_has_trace() {
  _has_bits_[1] |= 0x00000004u;
}
inline void Container::clear_has_trace() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void Container::clear_trace() {
  trace_ = false;
  clear_has_trace();
}
inline bool Container::trace() const {
  return trace_;
}
inline void Container::set_trace(bool value) {
  set_has_trace();
  trace_ = value;
}

// optional int32 instance = 77;
inline bool Container::has_instance() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void Container::set_has_instance() {
  _has_bits_[1] |= 0x00000008u;
}
inline void Container::clear_has_instance() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void Container::clear_instance() {
  instance_ = 0;
  clear_has_instance();
}
inline ::google::protobuf::int32 Container::instance() const {
  return instance_;
}
inline void Container::set_instance(::google::protobuf::int32 value) {
  set_has_instance();
  instance_ = value;
}

// repeated .pb.Value value = 85;
inline int Container::value_size() const {
  return value_.size();
}
inline void Container::clear_value() {
  value_.Clear();
}
inline const ::pb::Value& Container::value(int index) const {
  return value_.Get(index);
}
inline ::pb::Value* Container::mutable_value(int index) {
  return value_.Mutable(index);
}
inline ::pb::Value* Container::add_value() {
  return value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Value >&
Container::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Value >*
Container::mutable_value() {
  return &value_;
}

// optional .pb.RTAPICommand rtapicmd = 86;
inline bool Container::has_rtapicmd() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void Container::set_has_rtapicmd() {
  _has_bits_[1] |= 0x00000020u;
}
inline void Container::clear_has_rtapicmd() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void Container::clear_rtapicmd() {
  if (rtapicmd_ != NULL) rtapicmd_->::pb::RTAPICommand::Clear();
  clear_has_rtapicmd();
}
inline const ::pb::RTAPICommand& Container::rtapicmd() const {
  return rtapicmd_ != NULL ? *rtapicmd_ : *default_instance_->rtapicmd_;
}
inline ::pb::RTAPICommand* Container::mutable_rtapicmd() {
  set_has_rtapicmd();
  if (rtapicmd_ == NULL) rtapicmd_ = new ::pb::RTAPICommand;
  return rtapicmd_;
}
inline ::pb::RTAPICommand* Container::release_rtapicmd() {
  clear_has_rtapicmd();
  ::pb::RTAPICommand* temp = rtapicmd_;
  rtapicmd_ = NULL;
  return temp;
}

// repeated .pb.ServiceAnnouncement service_announcement = 88;
inline int Container::service_announcement_size() const {
  return service_announcement_.size();
}
inline void Container::clear_service_announcement() {
  service_announcement_.Clear();
}
inline const ::pb::ServiceAnnouncement& Container::service_announcement(int index) const {
  return service_announcement_.Get(index);
}
inline ::pb::ServiceAnnouncement* Container::mutable_service_announcement(int index) {
  return service_announcement_.Mutable(index);
}
inline ::pb::ServiceAnnouncement* Container::add_service_announcement() {
  return service_announcement_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::ServiceAnnouncement >&
Container::service_announcement() const {
  return service_announcement_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::ServiceAnnouncement >*
Container::mutable_service_announcement() {
  return &service_announcement_;
}

// repeated .pb.Component comp = 100;
inline int Container::comp_size() const {
  return comp_.size();
}
inline void Container::clear_comp() {
  comp_.Clear();
}
inline const ::pb::Component& Container::comp(int index) const {
  return comp_.Get(index);
}
inline ::pb::Component* Container::mutable_comp(int index) {
  return comp_.Mutable(index);
}
inline ::pb::Component* Container::add_comp() {
  return comp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Component >&
Container::comp() const {
  return comp_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Component >*
Container::mutable_comp() {
  return &comp_;
}

// repeated .pb.Pin pin = 2;
inline int Container::pin_size() const {
  return pin_.size();
}
inline void Container::clear_pin() {
  pin_.Clear();
}
inline const ::pb::Pin& Container::pin(int index) const {
  return pin_.Get(index);
}
inline ::pb::Pin* Container::mutable_pin(int index) {
  return pin_.Mutable(index);
}
inline ::pb::Pin* Container::add_pin() {
  return pin_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Pin >&
Container::pin() const {
  return pin_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Pin >*
Container::mutable_pin() {
  return &pin_;
}

// repeated .pb.Signal signal = 3;
inline int Container::signal_size() const {
  return signal_.size();
}
inline void Container::clear_signal() {
  signal_.Clear();
}
inline const ::pb::Signal& Container::signal(int index) const {
  return signal_.Get(index);
}
inline ::pb::Signal* Container::mutable_signal(int index) {
  return signal_.Mutable(index);
}
inline ::pb::Signal* Container::add_signal() {
  return signal_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Signal >&
Container::signal() const {
  return signal_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Signal >*
Container::mutable_signal() {
  return &signal_;
}

// repeated .pb.Param param = 103;
inline int Container::param_size() const {
  return param_.size();
}
inline void Container::clear_param() {
  param_.Clear();
}
inline const ::pb::Param& Container::param(int index) const {
  return param_.Get(index);
}
inline ::pb::Param* Container::mutable_param(int index) {
  return param_.Mutable(index);
}
inline ::pb::Param* Container::add_param() {
  return param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Param >&
Container::param() const {
  return param_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Param >*
Container::mutable_param() {
  return &param_;
}

// repeated .pb.Thread thread = 104;
inline int Container::thread_size() const {
  return thread_.size();
}
inline void Container::clear_thread() {
  thread_.Clear();
}
inline const ::pb::Thread& Container::thread(int index) const {
  return thread_.Get(index);
}
inline ::pb::Thread* Container::mutable_thread(int index) {
  return thread_.Mutable(index);
}
inline ::pb::Thread* Container::add_thread() {
  return thread_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Thread >&
Container::thread() const {
  return thread_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Thread >*
Container::mutable_thread() {
  return &thread_;
}

// repeated .pb.Ring ring = 105;
inline int Container::ring_size() const {
  return ring_.size();
}
inline void Container::clear_ring() {
  ring_.Clear();
}
inline const ::pb::Ring& Container::ring(int index) const {
  return ring_.Get(index);
}
inline ::pb::Ring* Container::mutable_ring(int index) {
  return ring_.Mutable(index);
}
inline ::pb::Ring* Container::add_ring() {
  return ring_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Ring >&
Container::ring() const {
  return ring_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Ring >*
Container::mutable_ring() {
  return &ring_;
}

// repeated .pb.Group group = 106;
inline int Container::group_size() const {
  return group_.size();
}
inline void Container::clear_group() {
  group_.Clear();
}
inline const ::pb::Group& Container::group(int index) const {
  return group_.Get(index);
}
inline ::pb::Group* Container::mutable_group(int index) {
  return group_.Mutable(index);
}
inline ::pb::Group* Container::add_group() {
  return group_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Group >&
Container::group() const {
  return group_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Group >*
Container::mutable_group() {
  return &group_;
}

// repeated .pb.Member member = 107;
inline int Container::member_size() const {
  return member_.size();
}
inline void Container::clear_member() {
  member_.Clear();
}
inline const ::pb::Member& Container::member(int index) const {
  return member_.Get(index);
}
inline ::pb::Member* Container::mutable_member(int index) {
  return member_.Mutable(index);
}
inline ::pb::Member* Container::add_member() {
  return member_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Member >&
Container::member() const {
  return member_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Member >*
Container::mutable_member() {
  return &member_;
}

// repeated .pb.Function function = 108;
inline int Container::function_size() const {
  return function_.size();
}
inline void Container::clear_function() {
  function_.Clear();
}
inline const ::pb::Function& Container::function(int index) const {
  return function_.Get(index);
}
inline ::pb::Function* Container::mutable_function(int index) {
  return function_.Mutable(index);
}
inline ::pb::Function* Container::add_function() {
  return function_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Function >&
Container::function() const {
  return function_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Function >*
Container::mutable_function() {
  return &function_;
}

// optional .pb.ProtocolParameters pparams = 109;
inline bool Container::has_pparams() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void Container::set_has_pparams() {
  _has_bits_[1] |= 0x00010000u;
}
inline void Container::clear_has_pparams() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void Container::clear_pparams() {
  if (pparams_ != NULL) pparams_->::pb::ProtocolParameters::Clear();
  clear_has_pparams();
}
inline const ::pb::ProtocolParameters& Container::pparams() const {
  return pparams_ != NULL ? *pparams_ : *default_instance_->pparams_;
}
inline ::pb::ProtocolParameters* Container::mutable_pparams() {
  set_has_pparams();
  if (pparams_ == NULL) pparams_ = new ::pb::ProtocolParameters;
  return pparams_;
}
inline ::pb::ProtocolParameters* Container::release_pparams() {
  clear_has_pparams();
  ::pb::ProtocolParameters* temp = pparams_;
  pparams_ = NULL;
  return temp;
}

// repeated .pb.Application app = 120;
inline int Container::app_size() const {
  return app_.size();
}
inline void Container::clear_app() {
  app_.Clear();
}
inline const ::pb::Application& Container::app(int index) const {
  return app_.Get(index);
}
inline ::pb::Application* Container::mutable_app(int index) {
  return app_.Mutable(index);
}
inline ::pb::Application* Container::add_app() {
  return app_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Application >&
Container::app() const {
  return app_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Application >*
Container::mutable_app() {
  return &app_;
}

// optional .pb.LogMessage log_message = 87;
inline bool Container::has_log_message() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void Container::set_has_log_message() {
  _has_bits_[1] |= 0x00040000u;
}
inline void Container::clear_has_log_message() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void Container::clear_log_message() {
  if (log_message_ != NULL) log_message_->::pb::LogMessage::Clear();
  clear_has_log_message();
}
inline const ::pb::LogMessage& Container::log_message() const {
  return log_message_ != NULL ? *log_message_ : *default_instance_->log_message_;
}
inline ::pb::LogMessage* Container::mutable_log_message() {
  set_has_log_message();
  if (log_message_ == NULL) log_message_ = new ::pb::LogMessage;
  return log_message_;
}
inline ::pb::LogMessage* Container::release_log_message() {
  clear_has_log_message();
  ::pb::LogMessage* temp = log_message_;
  log_message_ = NULL;
  return temp;
}

// optional .pb.TaskPlanExecute tpexecute = 200;
inline bool Container::has_tpexecute() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void Container::set_has_tpexecute() {
  _has_bits_[1] |= 0x00080000u;
}
inline void Container::clear_has_tpexecute() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void Container::clear_tpexecute() {
  if (tpexecute_ != NULL) tpexecute_->::pb::TaskPlanExecute::Clear();
  clear_has_tpexecute();
}
inline const ::pb::TaskPlanExecute& Container::tpexecute() const {
  return tpexecute_ != NULL ? *tpexecute_ : *default_instance_->tpexecute_;
}
inline ::pb::TaskPlanExecute* Container::mutable_tpexecute() {
  set_has_tpexecute();
  if (tpexecute_ == NULL) tpexecute_ = new ::pb::TaskPlanExecute;
  return tpexecute_;
}
inline ::pb::TaskPlanExecute* Container::release_tpexecute() {
  clear_has_tpexecute();
  ::pb::TaskPlanExecute* temp = tpexecute_;
  tpexecute_ = NULL;
  return temp;
}

// optional .pb.TaskPlanBlockDelete tpblockdelete = 201;
inline bool Container::has_tpblockdelete() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void Container::set_has_tpblockdelete() {
  _has_bits_[1] |= 0x00100000u;
}
inline void Container::clear_has_tpblockdelete() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void Container::clear_tpblockdelete() {
  if (tpblockdelete_ != NULL) tpblockdelete_->::pb::TaskPlanBlockDelete::Clear();
  clear_has_tpblockdelete();
}
inline const ::pb::TaskPlanBlockDelete& Container::tpblockdelete() const {
  return tpblockdelete_ != NULL ? *tpblockdelete_ : *default_instance_->tpblockdelete_;
}
inline ::pb::TaskPlanBlockDelete* Container::mutable_tpblockdelete() {
  set_has_tpblockdelete();
  if (tpblockdelete_ == NULL) tpblockdelete_ = new ::pb::TaskPlanBlockDelete;
  return tpblockdelete_;
}
inline ::pb::TaskPlanBlockDelete* Container::release_tpblockdelete() {
  clear_has_tpblockdelete();
  ::pb::TaskPlanBlockDelete* temp = tpblockdelete_;
  tpblockdelete_ = NULL;
  return temp;
}

// optional .pb.TaskPlanOptionalStop tpoptionalstop = 202;
inline bool Container::has_tpoptionalstop() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void Container::set_has_tpoptionalstop() {
  _has_bits_[1] |= 0x00200000u;
}
inline void Container::clear_has_tpoptionalstop() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void Container::clear_tpoptionalstop() {
  if (tpoptionalstop_ != NULL) tpoptionalstop_->::pb::TaskPlanOptionalStop::Clear();
  clear_has_tpoptionalstop();
}
inline const ::pb::TaskPlanOptionalStop& Container::tpoptionalstop() const {
  return tpoptionalstop_ != NULL ? *tpoptionalstop_ : *default_instance_->tpoptionalstop_;
}
inline ::pb::TaskPlanOptionalStop* Container::mutable_tpoptionalstop() {
  set_has_tpoptionalstop();
  if (tpoptionalstop_ == NULL) tpoptionalstop_ = new ::pb::TaskPlanOptionalStop;
  return tpoptionalstop_;
}
inline ::pb::TaskPlanOptionalStop* Container::release_tpoptionalstop() {
  clear_has_tpoptionalstop();
  ::pb::TaskPlanOptionalStop* temp = tpoptionalstop_;
  tpoptionalstop_ = NULL;
  return temp;
}

// optional .pb.TaskPlanOpen tpopen = 203;
inline bool Container::has_tpopen() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void Container::set_has_tpopen() {
  _has_bits_[1] |= 0x00400000u;
}
inline void Container::clear_has_tpopen() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void Container::clear_tpopen() {
  if (tpopen_ != NULL) tpopen_->::pb::TaskPlanOpen::Clear();
  clear_has_tpopen();
}
inline const ::pb::TaskPlanOpen& Container::tpopen() const {
  return tpopen_ != NULL ? *tpopen_ : *default_instance_->tpopen_;
}
inline ::pb::TaskPlanOpen* Container::mutable_tpopen() {
  set_has_tpopen();
  if (tpopen_ == NULL) tpopen_ = new ::pb::TaskPlanOpen;
  return tpopen_;
}
inline ::pb::TaskPlanOpen* Container::release_tpopen() {
  clear_has_tpopen();
  ::pb::TaskPlanOpen* temp = tpopen_;
  tpopen_ = NULL;
  return temp;
}

// optional .pb.TaskPlanReply taskplan_reply = 210;
inline bool Container::has_taskplan_reply() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void Container::set_has_taskplan_reply() {
  _has_bits_[1] |= 0x00800000u;
}
inline void Container::clear_has_taskplan_reply() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void Container::clear_taskplan_reply() {
  if (taskplan_reply_ != NULL) taskplan_reply_->::pb::TaskPlanReply::Clear();
  clear_has_taskplan_reply();
}
inline const ::pb::TaskPlanReply& Container::taskplan_reply() const {
  return taskplan_reply_ != NULL ? *taskplan_reply_ : *default_instance_->taskplan_reply_;
}
inline ::pb::TaskPlanReply* Container::mutable_taskplan_reply() {
  set_has_taskplan_reply();
  if (taskplan_reply_ == NULL) taskplan_reply_ = new ::pb::TaskPlanReply;
  return taskplan_reply_;
}
inline ::pb::TaskPlanReply* Container::release_taskplan_reply() {
  clear_has_taskplan_reply();
  ::pb::TaskPlanReply* temp = taskplan_reply_;
  taskplan_reply_ = NULL;
  return temp;
}

// optional .pb.Emc_Traj_Set_G5x traj_set_g5x = 300;
inline bool Container::has_traj_set_g5x() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void Container::set_has_traj_set_g5x() {
  _has_bits_[1] |= 0x01000000u;
}
inline void Container::clear_has_traj_set_g5x() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void Container::clear_traj_set_g5x() {
  if (traj_set_g5x_ != NULL) traj_set_g5x_->::pb::Emc_Traj_Set_G5x::Clear();
  clear_has_traj_set_g5x();
}
inline const ::pb::Emc_Traj_Set_G5x& Container::traj_set_g5x() const {
  return traj_set_g5x_ != NULL ? *traj_set_g5x_ : *default_instance_->traj_set_g5x_;
}
inline ::pb::Emc_Traj_Set_G5x* Container::mutable_traj_set_g5x() {
  set_has_traj_set_g5x();
  if (traj_set_g5x_ == NULL) traj_set_g5x_ = new ::pb::Emc_Traj_Set_G5x;
  return traj_set_g5x_;
}
inline ::pb::Emc_Traj_Set_G5x* Container::release_traj_set_g5x() {
  clear_has_traj_set_g5x();
  ::pb::Emc_Traj_Set_G5x* temp = traj_set_g5x_;
  traj_set_g5x_ = NULL;
  return temp;
}

// optional .pb.Emc_Traj_Set_G92 traj_set_g92 = 310;
inline bool Container::has_traj_set_g92() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void Container::set_has_traj_set_g92() {
  _has_bits_[1] |= 0x02000000u;
}
inline void Container::clear_has_traj_set_g92() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void Container::clear_traj_set_g92() {
  if (traj_set_g92_ != NULL) traj_set_g92_->::pb::Emc_Traj_Set_G92::Clear();
  clear_has_traj_set_g92();
}
inline const ::pb::Emc_Traj_Set_G92& Container::traj_set_g92() const {
  return traj_set_g92_ != NULL ? *traj_set_g92_ : *default_instance_->traj_set_g92_;
}
inline ::pb::Emc_Traj_Set_G92* Container::mutable_traj_set_g92() {
  set_has_traj_set_g92();
  if (traj_set_g92_ == NULL) traj_set_g92_ = new ::pb::Emc_Traj_Set_G92;
  return traj_set_g92_;
}
inline ::pb::Emc_Traj_Set_G92* Container::release_traj_set_g92() {
  clear_has_traj_set_g92();
  ::pb::Emc_Traj_Set_G92* temp = traj_set_g92_;
  traj_set_g92_ = NULL;
  return temp;
}

// optional .pb.Emc_Traj_Set_Rotation traj_set_rotation = 320;
inline bool Container::has_traj_set_rotation() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void Container::set_has_traj_set_rotation() {
  _has_bits_[1] |= 0x04000000u;
}
inline void Container::clear_has_traj_set_rotation() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void Container::clear_traj_set_rotation() {
  if (traj_set_rotation_ != NULL) traj_set_rotation_->::pb::Emc_Traj_Set_Rotation::Clear();
  clear_has_traj_set_rotation();
}
inline const ::pb::Emc_Traj_Set_Rotation& Container::traj_set_rotation() const {
  return traj_set_rotation_ != NULL ? *traj_set_rotation_ : *default_instance_->traj_set_rotation_;
}
inline ::pb::Emc_Traj_Set_Rotation* Container::mutable_traj_set_rotation() {
  set_has_traj_set_rotation();
  if (traj_set_rotation_ == NULL) traj_set_rotation_ = new ::pb::Emc_Traj_Set_Rotation;
  return traj_set_rotation_;
}
inline ::pb::Emc_Traj_Set_Rotation* Container::release_traj_set_rotation() {
  clear_has_traj_set_rotation();
  ::pb::Emc_Traj_Set_Rotation* temp = traj_set_rotation_;
  traj_set_rotation_ = NULL;
  return temp;
}

// optional .pb.Emc_Traj_Linear_Move traj_linear_move = 330;
inline bool Container::has_traj_linear_move() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void Container::set_has_traj_linear_move() {
  _has_bits_[1] |= 0x08000000u;
}
inline void Container::clear_has_traj_linear_move() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void Container::clear_traj_linear_move() {
  if (traj_linear_move_ != NULL) traj_linear_move_->::pb::Emc_Traj_Linear_Move::Clear();
  clear_has_traj_linear_move();
}
inline const ::pb::Emc_Traj_Linear_Move& Container::traj_linear_move() const {
  return traj_linear_move_ != NULL ? *traj_linear_move_ : *default_instance_->traj_linear_move_;
}
inline ::pb::Emc_Traj_Linear_Move* Container::mutable_traj_linear_move() {
  set_has_traj_linear_move();
  if (traj_linear_move_ == NULL) traj_linear_move_ = new ::pb::Emc_Traj_Linear_Move;
  return traj_linear_move_;
}
inline ::pb::Emc_Traj_Linear_Move* Container::release_traj_linear_move() {
  clear_has_traj_linear_move();
  ::pb::Emc_Traj_Linear_Move* temp = traj_linear_move_;
  traj_linear_move_ = NULL;
  return temp;
}

// optional .pb.Emc_Traj_Probe traj_probe = 340;
inline bool Container::has_traj_probe() const {
  return (_has_bits_[1] & 0x10000000u) != 0;
}
inline void Container::set_has_traj_probe() {
  _has_bits_[1] |= 0x10000000u;
}
inline void Container::clear_has_traj_probe() {
  _has_bits_[1] &= ~0x10000000u;
}
inline void Container::clear_traj_probe() {
  if (traj_probe_ != NULL) traj_probe_->::pb::Emc_Traj_Probe::Clear();
  clear_has_traj_probe();
}
inline const ::pb::Emc_Traj_Probe& Container::traj_probe() const {
  return traj_probe_ != NULL ? *traj_probe_ : *default_instance_->traj_probe_;
}
inline ::pb::Emc_Traj_Probe* Container::mutable_traj_probe() {
  set_has_traj_probe();
  if (traj_probe_ == NULL) traj_probe_ = new ::pb::Emc_Traj_Probe;
  return traj_probe_;
}
inline ::pb::Emc_Traj_Probe* Container::release_traj_probe() {
  clear_has_traj_probe();
  ::pb::Emc_Traj_Probe* temp = traj_probe_;
  traj_probe_ = NULL;
  return temp;
}

// optional .pb.Emc_Traj_Circular_Move traj_circular_move = 350;
inline bool Container::has_traj_circular_move() const {
  return (_has_bits_[1] & 0x20000000u) != 0;
}
inline void Container::set_has_traj_circular_move() {
  _has_bits_[1] |= 0x20000000u;
}
inline void Container::clear_has_traj_circular_move() {
  _has_bits_[1] &= ~0x20000000u;
}
inline void Container::clear_traj_circular_move() {
  if (traj_circular_move_ != NULL) traj_circular_move_->::pb::Emc_Traj_Circular_Move::Clear();
  clear_has_traj_circular_move();
}
inline const ::pb::Emc_Traj_Circular_Move& Container::traj_circular_move() const {
  return traj_circular_move_ != NULL ? *traj_circular_move_ : *default_instance_->traj_circular_move_;
}
inline ::pb::Emc_Traj_Circular_Move* Container::mutable_traj_circular_move() {
  set_has_traj_circular_move();
  if (traj_circular_move_ == NULL) traj_circular_move_ = new ::pb::Emc_Traj_Circular_Move;
  return traj_circular_move_;
}
inline ::pb::Emc_Traj_Circular_Move* Container::release_traj_circular_move() {
  clear_has_traj_circular_move();
  ::pb::Emc_Traj_Circular_Move* temp = traj_circular_move_;
  traj_circular_move_ = NULL;
  return temp;
}

// optional .pb.Emc_Traj_Rigid_Tap traj_rigid_tap = 360;
inline bool Container::has_traj_rigid_tap() const {
  return (_has_bits_[1] & 0x40000000u) != 0;
}
inline void Container::set_has_traj_rigid_tap() {
  _has_bits_[1] |= 0x40000000u;
}
inline void Container::clear_has_traj_rigid_tap() {
  _has_bits_[1] &= ~0x40000000u;
}
inline void Container::clear_traj_rigid_tap() {
  if (traj_rigid_tap_ != NULL) traj_rigid_tap_->::pb::Emc_Traj_Rigid_Tap::Clear();
  clear_has_traj_rigid_tap();
}
inline const ::pb::Emc_Traj_Rigid_Tap& Container::traj_rigid_tap() const {
  return traj_rigid_tap_ != NULL ? *traj_rigid_tap_ : *default_instance_->traj_rigid_tap_;
}
inline ::pb::Emc_Traj_Rigid_Tap* Container::mutable_traj_rigid_tap() {
  set_has_traj_rigid_tap();
  if (traj_rigid_tap_ == NULL) traj_rigid_tap_ = new ::pb::Emc_Traj_Rigid_Tap;
  return traj_rigid_tap_;
}
inline ::pb::Emc_Traj_Rigid_Tap* Container::release_traj_rigid_tap() {
  clear_has_traj_rigid_tap();
  ::pb::Emc_Traj_Rigid_Tap* temp = traj_rigid_tap_;
  traj_rigid_tap_ = NULL;
  return temp;
}

// optional .pb.Emc_Traj_Set_Term_Cond traj_set_term_cond = 370;
inline bool Container::has_traj_set_term_cond() const {
  return (_has_bits_[1] & 0x80000000u) != 0;
}
inline void Container::set_has_traj_set_term_cond() {
  _has_bits_[1] |= 0x80000000u;
}
inline void Container::clear_has_traj_set_term_cond() {
  _has_bits_[1] &= ~0x80000000u;
}
inline void Container::clear_traj_set_term_cond() {
  if (traj_set_term_cond_ != NULL) traj_set_term_cond_->::pb::Emc_Traj_Set_Term_Cond::Clear();
  clear_has_traj_set_term_cond();
}
inline const ::pb::Emc_Traj_Set_Term_Cond& Container::traj_set_term_cond() const {
  return traj_set_term_cond_ != NULL ? *traj_set_term_cond_ : *default_instance_->traj_set_term_cond_;
}
inline ::pb::Emc_Traj_Set_Term_Cond* Container::mutable_traj_set_term_cond() {
  set_has_traj_set_term_cond();
  if (traj_set_term_cond_ == NULL) traj_set_term_cond_ = new ::pb::Emc_Traj_Set_Term_Cond;
  return traj_set_term_cond_;
}
inline ::pb::Emc_Traj_Set_Term_Cond* Container::release_traj_set_term_cond() {
  clear_has_traj_set_term_cond();
  ::pb::Emc_Traj_Set_Term_Cond* temp = traj_set_term_cond_;
  traj_set_term_cond_ = NULL;
  return temp;
}

// optional .pb.Emc_Traj_Set_Spindlesync traj_set_spindlesync = 380;
inline bool Container::has_traj_set_spindlesync() const {
  return (_has_bits_[2] & 0x00000001u) != 0;
}
inline void Container::set_has_traj_set_spindlesync() {
  _has_bits_[2] |= 0x00000001u;
}
inline void Container::clear_has_traj_set_spindlesync() {
  _has_bits_[2] &= ~0x00000001u;
}
inline void Container::clear_traj_set_spindlesync() {
  if (traj_set_spindlesync_ != NULL) traj_set_spindlesync_->::pb::Emc_Traj_Set_Spindlesync::Clear();
  clear_has_traj_set_spindlesync();
}
inline const ::pb::Emc_Traj_Set_Spindlesync& Container::traj_set_spindlesync() const {
  return traj_set_spindlesync_ != NULL ? *traj_set_spindlesync_ : *default_instance_->traj_set_spindlesync_;
}
inline ::pb::Emc_Traj_Set_Spindlesync* Container::mutable_traj_set_spindlesync() {
  set_has_traj_set_spindlesync();
  if (traj_set_spindlesync_ == NULL) traj_set_spindlesync_ = new ::pb::Emc_Traj_Set_Spindlesync;
  return traj_set_spindlesync_;
}
inline ::pb::Emc_Traj_Set_Spindlesync* Container::release_traj_set_spindlesync() {
  clear_has_traj_set_spindlesync();
  ::pb::Emc_Traj_Set_Spindlesync* temp = traj_set_spindlesync_;
  traj_set_spindlesync_ = NULL;
  return temp;
}

// optional .pb.Emc_Traj_Delay traj_delay = 390;
inline bool Container::has_traj_delay() const {
  return (_has_bits_[2] & 0x00000002u) != 0;
}
inline void Container::set_has_traj_delay() {
  _has_bits_[2] |= 0x00000002u;
}
inline void Container::clear_has_traj_delay() {
  _has_bits_[2] &= ~0x00000002u;
}
inline void Container::clear_traj_delay() {
  if (traj_delay_ != NULL) traj_delay_->::pb::Emc_Traj_Delay::Clear();
  clear_has_traj_delay();
}
inline const ::pb::Emc_Traj_Delay& Container::traj_delay() const {
  return traj_delay_ != NULL ? *traj_delay_ : *default_instance_->traj_delay_;
}
inline ::pb::Emc_Traj_Delay* Container::mutable_traj_delay() {
  set_has_traj_delay();
  if (traj_delay_ == NULL) traj_delay_ = new ::pb::Emc_Traj_Delay;
  return traj_delay_;
}
inline ::pb::Emc_Traj_Delay* Container::release_traj_delay() {
  clear_has_traj_delay();
  ::pb::Emc_Traj_Delay* temp = traj_delay_;
  traj_delay_ = NULL;
  return temp;
}

// optional .pb.Emc_Spindle_On spindle_on = 400;
inline bool Container::has_spindle_on() const {
  return (_has_bits_[2] & 0x00000004u) != 0;
}
inline void Container::set_has_spindle_on() {
  _has_bits_[2] |= 0x00000004u;
}
inline void Container::clear_has_spindle_on() {
  _has_bits_[2] &= ~0x00000004u;
}
inline void Container::clear_spindle_on() {
  if (spindle_on_ != NULL) spindle_on_->::pb::Emc_Spindle_On::Clear();
  clear_has_spindle_on();
}
inline const ::pb::Emc_Spindle_On& Container::spindle_on() const {
  return spindle_on_ != NULL ? *spindle_on_ : *default_instance_->spindle_on_;
}
inline ::pb::Emc_Spindle_On* Container::mutable_spindle_on() {
  set_has_spindle_on();
  if (spindle_on_ == NULL) spindle_on_ = new ::pb::Emc_Spindle_On;
  return spindle_on_;
}
inline ::pb::Emc_Spindle_On* Container::release_spindle_on() {
  clear_has_spindle_on();
  ::pb::Emc_Spindle_On* temp = spindle_on_;
  spindle_on_ = NULL;
  return temp;
}

// optional .pb.Emc_Spindle_Speed spindle_speed = 410;
inline bool Container::has_spindle_speed() const {
  return (_has_bits_[2] & 0x00000008u) != 0;
}
inline void Container::set_has_spindle_speed() {
  _has_bits_[2] |= 0x00000008u;
}
inline void Container::clear_has_spindle_speed() {
  _has_bits_[2] &= ~0x00000008u;
}
inline void Container::clear_spindle_speed() {
  if (spindle_speed_ != NULL) spindle_speed_->::pb::Emc_Spindle_Speed::Clear();
  clear_has_spindle_speed();
}
inline const ::pb::Emc_Spindle_Speed& Container::spindle_speed() const {
  return spindle_speed_ != NULL ? *spindle_speed_ : *default_instance_->spindle_speed_;
}
inline ::pb::Emc_Spindle_Speed* Container::mutable_spindle_speed() {
  set_has_spindle_speed();
  if (spindle_speed_ == NULL) spindle_speed_ = new ::pb::Emc_Spindle_Speed;
  return spindle_speed_;
}
inline ::pb::Emc_Spindle_Speed* Container::release_spindle_speed() {
  clear_has_spindle_speed();
  ::pb::Emc_Spindle_Speed* temp = spindle_speed_;
  spindle_speed_ = NULL;
  return temp;
}

// optional .pb.Emc_Spindle_Orient spindle_orient = 420;
inline bool Container::has_spindle_orient() const {
  return (_has_bits_[2] & 0x00000010u) != 0;
}
inline void Container::set_has_spindle_orient() {
  _has_bits_[2] |= 0x00000010u;
}
inline void Container::clear_has_spindle_orient() {
  _has_bits_[2] &= ~0x00000010u;
}
inline void Container::clear_spindle_orient() {
  if (spindle_orient_ != NULL) spindle_orient_->::pb::Emc_Spindle_Orient::Clear();
  clear_has_spindle_orient();
}
inline const ::pb::Emc_Spindle_Orient& Container::spindle_orient() const {
  return spindle_orient_ != NULL ? *spindle_orient_ : *default_instance_->spindle_orient_;
}
inline ::pb::Emc_Spindle_Orient* Container::mutable_spindle_orient() {
  set_has_spindle_orient();
  if (spindle_orient_ == NULL) spindle_orient_ = new ::pb::Emc_Spindle_Orient;
  return spindle_orient_;
}
inline ::pb::Emc_Spindle_Orient* Container::release_spindle_orient() {
  clear_has_spindle_orient();
  ::pb::Emc_Spindle_Orient* temp = spindle_orient_;
  spindle_orient_ = NULL;
  return temp;
}

// optional .pb.Emc_Spindle_Wait_Orient_Complete spindle_wait_orient_complete = 430;
inline bool Container::has_spindle_wait_orient_complete() const {
  return (_has_bits_[2] & 0x00000020u) != 0;
}
inline void Container::set_has_spindle_wait_orient_complete() {
  _has_bits_[2] |= 0x00000020u;
}
inline void Container::clear_has_spindle_wait_orient_complete() {
  _has_bits_[2] &= ~0x00000020u;
}
inline void Container::clear_spindle_wait_orient_complete() {
  if (spindle_wait_orient_complete_ != NULL) spindle_wait_orient_complete_->::pb::Emc_Spindle_Wait_Orient_Complete::Clear();
  clear_has_spindle_wait_orient_complete();
}
inline const ::pb::Emc_Spindle_Wait_Orient_Complete& Container::spindle_wait_orient_complete() const {
  return spindle_wait_orient_complete_ != NULL ? *spindle_wait_orient_complete_ : *default_instance_->spindle_wait_orient_complete_;
}
inline ::pb::Emc_Spindle_Wait_Orient_Complete* Container::mutable_spindle_wait_orient_complete() {
  set_has_spindle_wait_orient_complete();
  if (spindle_wait_orient_complete_ == NULL) spindle_wait_orient_complete_ = new ::pb::Emc_Spindle_Wait_Orient_Complete;
  return spindle_wait_orient_complete_;
}
inline ::pb::Emc_Spindle_Wait_Orient_Complete* Container::release_spindle_wait_orient_complete() {
  clear_has_spindle_wait_orient_complete();
  ::pb::Emc_Spindle_Wait_Orient_Complete* temp = spindle_wait_orient_complete_;
  spindle_wait_orient_complete_ = NULL;
  return temp;
}

// optional .pb.Emc_Tool_Set_Offset tool_set_offet = 440;
inline bool Container::has_tool_set_offet() const {
  return (_has_bits_[2] & 0x00000040u) != 0;
}
inline void Container::set_has_tool_set_offet() {
  _has_bits_[2] |= 0x00000040u;
}
inline void Container::clear_has_tool_set_offet() {
  _has_bits_[2] &= ~0x00000040u;
}
inline void Container::clear_tool_set_offet() {
  if (tool_set_offet_ != NULL) tool_set_offet_->::pb::Emc_Tool_Set_Offset::Clear();
  clear_has_tool_set_offet();
}
inline const ::pb::Emc_Tool_Set_Offset& Container::tool_set_offet() const {
  return tool_set_offet_ != NULL ? *tool_set_offet_ : *default_instance_->tool_set_offet_;
}
inline ::pb::Emc_Tool_Set_Offset* Container::mutable_tool_set_offet() {
  set_has_tool_set_offet();
  if (tool_set_offet_ == NULL) tool_set_offet_ = new ::pb::Emc_Tool_Set_Offset;
  return tool_set_offet_;
}
inline ::pb::Emc_Tool_Set_Offset* Container::release_tool_set_offet() {
  clear_has_tool_set_offet();
  ::pb::Emc_Tool_Set_Offset* temp = tool_set_offet_;
  tool_set_offet_ = NULL;
  return temp;
}

// optional .pb.Emc_Traj_Set_Offset traj_set_offset = 450;
inline bool Container::has_traj_set_offset() const {
  return (_has_bits_[2] & 0x00000080u) != 0;
}
inline void Container::set_has_traj_set_offset() {
  _has_bits_[2] |= 0x00000080u;
}
inline void Container::clear_has_traj_set_offset() {
  _has_bits_[2] &= ~0x00000080u;
}
inline void Container::clear_traj_set_offset() {
  if (traj_set_offset_ != NULL) traj_set_offset_->::pb::Emc_Traj_Set_Offset::Clear();
  clear_has_traj_set_offset();
}
inline const ::pb::Emc_Traj_Set_Offset& Container::traj_set_offset() const {
  return traj_set_offset_ != NULL ? *traj_set_offset_ : *default_instance_->traj_set_offset_;
}
inline ::pb::Emc_Traj_Set_Offset* Container::mutable_traj_set_offset() {
  set_has_traj_set_offset();
  if (traj_set_offset_ == NULL) traj_set_offset_ = new ::pb::Emc_Traj_Set_Offset;
  return traj_set_offset_;
}
inline ::pb::Emc_Traj_Set_Offset* Container::release_traj_set_offset() {
  clear_has_traj_set_offset();
  ::pb::Emc_Traj_Set_Offset* temp = traj_set_offset_;
  traj_set_offset_ = NULL;
  return temp;
}

// optional .pb.Emc_Tool_Prepare tool_prepare = 460;
inline bool Container::has_tool_prepare() const {
  return (_has_bits_[2] & 0x00000100u) != 0;
}
inline void Container::set_has_tool_prepare() {
  _has_bits_[2] |= 0x00000100u;
}
inline void Container::clear_has_tool_prepare() {
  _has_bits_[2] &= ~0x00000100u;
}
inline void Container::clear_tool_prepare() {
  if (tool_prepare_ != NULL) tool_prepare_->::pb::Emc_Tool_Prepare::Clear();
  clear_has_tool_prepare();
}
inline const ::pb::Emc_Tool_Prepare& Container::tool_prepare() const {
  return tool_prepare_ != NULL ? *tool_prepare_ : *default_instance_->tool_prepare_;
}
inline ::pb::Emc_Tool_Prepare* Container::mutable_tool_prepare() {
  set_has_tool_prepare();
  if (tool_prepare_ == NULL) tool_prepare_ = new ::pb::Emc_Tool_Prepare;
  return tool_prepare_;
}
inline ::pb::Emc_Tool_Prepare* Container::release_tool_prepare() {
  clear_has_tool_prepare();
  ::pb::Emc_Tool_Prepare* temp = tool_prepare_;
  tool_prepare_ = NULL;
  return temp;
}

// optional .pb.Emc_Tool_Set_Number tool_set_number = 470;
inline bool Container::has_tool_set_number() const {
  return (_has_bits_[2] & 0x00000200u) != 0;
}
inline void Container::set_has_tool_set_number() {
  _has_bits_[2] |= 0x00000200u;
}
inline void Container::clear_has_tool_set_number() {
  _has_bits_[2] &= ~0x00000200u;
}
inline void Container::clear_tool_set_number() {
  if (tool_set_number_ != NULL) tool_set_number_->::pb::Emc_Tool_Set_Number::Clear();
  clear_has_tool_set_number();
}
inline const ::pb::Emc_Tool_Set_Number& Container::tool_set_number() const {
  return tool_set_number_ != NULL ? *tool_set_number_ : *default_instance_->tool_set_number_;
}
inline ::pb::Emc_Tool_Set_Number* Container::mutable_tool_set_number() {
  set_has_tool_set_number();
  if (tool_set_number_ == NULL) tool_set_number_ = new ::pb::Emc_Tool_Set_Number;
  return tool_set_number_;
}
inline ::pb::Emc_Tool_Set_Number* Container::release_tool_set_number() {
  clear_has_tool_set_number();
  ::pb::Emc_Tool_Set_Number* temp = tool_set_number_;
  tool_set_number_ = NULL;
  return temp;
}

// optional .pb.Emc_Traj_Set_Fo_Enable traj_set_fo_enable = 480;
inline bool Container::has_traj_set_fo_enable() const {
  return (_has_bits_[2] & 0x00000400u) != 0;
}
inline void Container::set_has_traj_set_fo_enable() {
  _has_bits_[2] |= 0x00000400u;
}
inline void Container::clear_has_traj_set_fo_enable() {
  _has_bits_[2] &= ~0x00000400u;
}
inline void Container::clear_traj_set_fo_enable() {
  if (traj_set_fo_enable_ != NULL) traj_set_fo_enable_->::pb::Emc_Traj_Set_Fo_Enable::Clear();
  clear_has_traj_set_fo_enable();
}
inline const ::pb::Emc_Traj_Set_Fo_Enable& Container::traj_set_fo_enable() const {
  return traj_set_fo_enable_ != NULL ? *traj_set_fo_enable_ : *default_instance_->traj_set_fo_enable_;
}
inline ::pb::Emc_Traj_Set_Fo_Enable* Container::mutable_traj_set_fo_enable() {
  set_has_traj_set_fo_enable();
  if (traj_set_fo_enable_ == NULL) traj_set_fo_enable_ = new ::pb::Emc_Traj_Set_Fo_Enable;
  return traj_set_fo_enable_;
}
inline ::pb::Emc_Traj_Set_Fo_Enable* Container::release_traj_set_fo_enable() {
  clear_has_traj_set_fo_enable();
  ::pb::Emc_Traj_Set_Fo_Enable* temp = traj_set_fo_enable_;
  traj_set_fo_enable_ = NULL;
  return temp;
}

// optional .pb.Emc_Traj_Set_So_Enable traj_set_so_enable = 490;
inline bool Container::has_traj_set_so_enable() const {
  return (_has_bits_[2] & 0x00000800u) != 0;
}
inline void Container::set_has_traj_set_so_enable() {
  _has_bits_[2] |= 0x00000800u;
}
inline void Container::clear_has_traj_set_so_enable() {
  _has_bits_[2] &= ~0x00000800u;
}
inline void Container::clear_traj_set_so_enable() {
  if (traj_set_so_enable_ != NULL) traj_set_so_enable_->::pb::Emc_Traj_Set_So_Enable::Clear();
  clear_has_traj_set_so_enable();
}
inline const ::pb::Emc_Traj_Set_So_Enable& Container::traj_set_so_enable() const {
  return traj_set_so_enable_ != NULL ? *traj_set_so_enable_ : *default_instance_->traj_set_so_enable_;
}
inline ::pb::Emc_Traj_Set_So_Enable* Container::mutable_traj_set_so_enable() {
  set_has_traj_set_so_enable();
  if (traj_set_so_enable_ == NULL) traj_set_so_enable_ = new ::pb::Emc_Traj_Set_So_Enable;
  return traj_set_so_enable_;
}
inline ::pb::Emc_Traj_Set_So_Enable* Container::release_traj_set_so_enable() {
  clear_has_traj_set_so_enable();
  ::pb::Emc_Traj_Set_So_Enable* temp = traj_set_so_enable_;
  traj_set_so_enable_ = NULL;
  return temp;
}

// optional .pb.Emc_Traj_Set_Fh_Enable traj_set_fh_enable = 500;
inline bool Container::has_traj_set_fh_enable() const {
  return (_has_bits_[2] & 0x00001000u) != 0;
}
inline void Container::set_has_traj_set_fh_enable() {
  _has_bits_[2] |= 0x00001000u;
}
inline void Container::clear_has_traj_set_fh_enable() {
  _has_bits_[2] &= ~0x00001000u;
}
inline void Container::clear_traj_set_fh_enable() {
  if (traj_set_fh_enable_ != NULL) traj_set_fh_enable_->::pb::Emc_Traj_Set_Fh_Enable::Clear();
  clear_has_traj_set_fh_enable();
}
inline const ::pb::Emc_Traj_Set_Fh_Enable& Container::traj_set_fh_enable() const {
  return traj_set_fh_enable_ != NULL ? *traj_set_fh_enable_ : *default_instance_->traj_set_fh_enable_;
}
inline ::pb::Emc_Traj_Set_Fh_Enable* Container::mutable_traj_set_fh_enable() {
  set_has_traj_set_fh_enable();
  if (traj_set_fh_enable_ == NULL) traj_set_fh_enable_ = new ::pb::Emc_Traj_Set_Fh_Enable;
  return traj_set_fh_enable_;
}
inline ::pb::Emc_Traj_Set_Fh_Enable* Container::release_traj_set_fh_enable() {
  clear_has_traj_set_fh_enable();
  ::pb::Emc_Traj_Set_Fh_Enable* temp = traj_set_fh_enable_;
  traj_set_fh_enable_ = NULL;
  return temp;
}

// optional .pb.Emc_Motion_Adaptive motion_adaptive = 510;
inline bool Container::has_motion_adaptive() const {
  return (_has_bits_[2] & 0x00002000u) != 0;
}
inline void Container::set_has_motion_adaptive() {
  _has_bits_[2] |= 0x00002000u;
}
inline void Container::clear_has_motion_adaptive() {
  _has_bits_[2] &= ~0x00002000u;
}
inline void Container::clear_motion_adaptive() {
  if (motion_adaptive_ != NULL) motion_adaptive_->::pb::Emc_Motion_Adaptive::Clear();
  clear_has_motion_adaptive();
}
inline const ::pb::Emc_Motion_Adaptive& Container::motion_adaptive() const {
  return motion_adaptive_ != NULL ? *motion_adaptive_ : *default_instance_->motion_adaptive_;
}
inline ::pb::Emc_Motion_Adaptive* Container::mutable_motion_adaptive() {
  set_has_motion_adaptive();
  if (motion_adaptive_ == NULL) motion_adaptive_ = new ::pb::Emc_Motion_Adaptive;
  return motion_adaptive_;
}
inline ::pb::Emc_Motion_Adaptive* Container::release_motion_adaptive() {
  clear_has_motion_adaptive();
  ::pb::Emc_Motion_Adaptive* temp = motion_adaptive_;
  motion_adaptive_ = NULL;
  return temp;
}

// optional .pb.Emc_Operator_Display operator_display = 520;
inline bool Container::has_operator_display() const {
  return (_has_bits_[2] & 0x00004000u) != 0;
}
inline void Container::set_has_operator_display() {
  _has_bits_[2] |= 0x00004000u;
}
inline void Container::clear_has_operator_display() {
  _has_bits_[2] &= ~0x00004000u;
}
inline void Container::clear_operator_display() {
  if (operator_display_ != NULL) operator_display_->::pb::Emc_Operator_Display::Clear();
  clear_has_operator_display();
}
inline const ::pb::Emc_Operator_Display& Container::operator_display() const {
  return operator_display_ != NULL ? *operator_display_ : *default_instance_->operator_display_;
}
inline ::pb::Emc_Operator_Display* Container::mutable_operator_display() {
  set_has_operator_display();
  if (operator_display_ == NULL) operator_display_ = new ::pb::Emc_Operator_Display;
  return operator_display_;
}
inline ::pb::Emc_Operator_Display* Container::release_operator_display() {
  clear_has_operator_display();
  ::pb::Emc_Operator_Display* temp = operator_display_;
  operator_display_ = NULL;
  return temp;
}

// optional .pb.Emc_Operator_Text operator_text = 530;
inline bool Container::has_operator_text() const {
  return (_has_bits_[2] & 0x00008000u) != 0;
}
inline void Container::set_has_operator_text() {
  _has_bits_[2] |= 0x00008000u;
}
inline void Container::clear_has_operator_text() {
  _has_bits_[2] &= ~0x00008000u;
}
inline void Container::clear_operator_text() {
  if (operator_text_ != NULL) operator_text_->::pb::Emc_Operator_Text::Clear();
  clear_has_operator_text();
}
inline const ::pb::Emc_Operator_Text& Container::operator_text() const {
  return operator_text_ != NULL ? *operator_text_ : *default_instance_->operator_text_;
}
inline ::pb::Emc_Operator_Text* Container::mutable_operator_text() {
  set_has_operator_text();
  if (operator_text_ == NULL) operator_text_ = new ::pb::Emc_Operator_Text;
  return operator_text_;
}
inline ::pb::Emc_Operator_Text* Container::release_operator_text() {
  clear_has_operator_text();
  ::pb::Emc_Operator_Text* temp = operator_text_;
  operator_text_ = NULL;
  return temp;
}

// optional .pb.Emc_Operator_Error operator_error = 540;
inline bool Container::has_operator_error() const {
  return (_has_bits_[2] & 0x00010000u) != 0;
}
inline void Container::set_has_operator_error() {
  _has_bits_[2] |= 0x00010000u;
}
inline void Container::clear_has_operator_error() {
  _has_bits_[2] &= ~0x00010000u;
}
inline void Container::clear_operator_error() {
  if (operator_error_ != NULL) operator_error_->::pb::Emc_Operator_Error::Clear();
  clear_has_operator_error();
}
inline const ::pb::Emc_Operator_Error& Container::operator_error() const {
  return operator_error_ != NULL ? *operator_error_ : *default_instance_->operator_error_;
}
inline ::pb::Emc_Operator_Error* Container::mutable_operator_error() {
  set_has_operator_error();
  if (operator_error_ == NULL) operator_error_ = new ::pb::Emc_Operator_Error;
  return operator_error_;
}
inline ::pb::Emc_Operator_Error* Container::release_operator_error() {
  clear_has_operator_error();
  ::pb::Emc_Operator_Error* temp = operator_error_;
  operator_error_ = NULL;
  return temp;
}

// optional .pb.Emc_Motion_Set_Dout motion_set_dout = 550;
inline bool Container::has_motion_set_dout() const {
  return (_has_bits_[2] & 0x00020000u) != 0;
}
inline void Container::set_has_motion_set_dout() {
  _has_bits_[2] |= 0x00020000u;
}
inline void Container::clear_has_motion_set_dout() {
  _has_bits_[2] &= ~0x00020000u;
}
inline void Container::clear_motion_set_dout() {
  if (motion_set_dout_ != NULL) motion_set_dout_->::pb::Emc_Motion_Set_Dout::Clear();
  clear_has_motion_set_dout();
}
inline const ::pb::Emc_Motion_Set_Dout& Container::motion_set_dout() const {
  return motion_set_dout_ != NULL ? *motion_set_dout_ : *default_instance_->motion_set_dout_;
}
inline ::pb::Emc_Motion_Set_Dout* Container::mutable_motion_set_dout() {
  set_has_motion_set_dout();
  if (motion_set_dout_ == NULL) motion_set_dout_ = new ::pb::Emc_Motion_Set_Dout;
  return motion_set_dout_;
}
inline ::pb::Emc_Motion_Set_Dout* Container::release_motion_set_dout() {
  clear_has_motion_set_dout();
  ::pb::Emc_Motion_Set_Dout* temp = motion_set_dout_;
  motion_set_dout_ = NULL;
  return temp;
}

// optional .pb.Emc_Motion_Set_Aout motion_set_aout = 560;
inline bool Container::has_motion_set_aout() const {
  return (_has_bits_[2] & 0x00040000u) != 0;
}
inline void Container::set_has_motion_set_aout() {
  _has_bits_[2] |= 0x00040000u;
}
inline void Container::clear_has_motion_set_aout() {
  _has_bits_[2] &= ~0x00040000u;
}
inline void Container::clear_motion_set_aout() {
  if (motion_set_aout_ != NULL) motion_set_aout_->::pb::Emc_Motion_Set_Aout::Clear();
  clear_has_motion_set_aout();
}
inline const ::pb::Emc_Motion_Set_Aout& Container::motion_set_aout() const {
  return motion_set_aout_ != NULL ? *motion_set_aout_ : *default_instance_->motion_set_aout_;
}
inline ::pb::Emc_Motion_Set_Aout* Container::mutable_motion_set_aout() {
  set_has_motion_set_aout();
  if (motion_set_aout_ == NULL) motion_set_aout_ = new ::pb::Emc_Motion_Set_Aout;
  return motion_set_aout_;
}
inline ::pb::Emc_Motion_Set_Aout* Container::release_motion_set_aout() {
  clear_has_motion_set_aout();
  ::pb::Emc_Motion_Set_Aout* temp = motion_set_aout_;
  motion_set_aout_ = NULL;
  return temp;
}

// optional .pb.Emc_Aux_Input_Wait aux_input_wait = 570;
inline bool Container::has_aux_input_wait() const {
  return (_has_bits_[2] & 0x00080000u) != 0;
}
inline void Container::set_has_aux_input_wait() {
  _has_bits_[2] |= 0x00080000u;
}
inline void Container::clear_has_aux_input_wait() {
  _has_bits_[2] &= ~0x00080000u;
}
inline void Container::clear_aux_input_wait() {
  if (aux_input_wait_ != NULL) aux_input_wait_->::pb::Emc_Aux_Input_Wait::Clear();
  clear_has_aux_input_wait();
}
inline const ::pb::Emc_Aux_Input_Wait& Container::aux_input_wait() const {
  return aux_input_wait_ != NULL ? *aux_input_wait_ : *default_instance_->aux_input_wait_;
}
inline ::pb::Emc_Aux_Input_Wait* Container::mutable_aux_input_wait() {
  set_has_aux_input_wait();
  if (aux_input_wait_ == NULL) aux_input_wait_ = new ::pb::Emc_Aux_Input_Wait;
  return aux_input_wait_;
}
inline ::pb::Emc_Aux_Input_Wait* Container::release_aux_input_wait() {
  clear_has_aux_input_wait();
  ::pb::Emc_Aux_Input_Wait* temp = aux_input_wait_;
  aux_input_wait_ = NULL;
  return temp;
}

// optional .pb.Emc_Exec_Plugin_Ca1l exec_plugin_call = 580;
inline bool Container::has_exec_plugin_call() const {
  return (_has_bits_[2] & 0x00100000u) != 0;
}
inline void Container::set_has_exec_plugin_call() {
  _has_bits_[2] |= 0x00100000u;
}
inline void Container::clear_has_exec_plugin_call() {
  _has_bits_[2] &= ~0x00100000u;
}
inline void Container::clear_exec_plugin_call() {
  if (exec_plugin_call_ != NULL) exec_plugin_call_->::pb::Emc_Exec_Plugin_Ca1l::Clear();
  clear_has_exec_plugin_call();
}
inline const ::pb::Emc_Exec_Plugin_Ca1l& Container::exec_plugin_call() const {
  return exec_plugin_call_ != NULL ? *exec_plugin_call_ : *default_instance_->exec_plugin_call_;
}
inline ::pb::Emc_Exec_Plugin_Ca1l* Container::mutable_exec_plugin_call() {
  set_has_exec_plugin_call();
  if (exec_plugin_call_ == NULL) exec_plugin_call_ = new ::pb::Emc_Exec_Plugin_Ca1l;
  return exec_plugin_call_;
}
inline ::pb::Emc_Exec_Plugin_Ca1l* Container::release_exec_plugin_call() {
  clear_has_exec_plugin_call();
  ::pb::Emc_Exec_Plugin_Ca1l* temp = exec_plugin_call_;
  exec_plugin_call_ = NULL;
  return temp;
}

// optional .pb.Emc_Io_Plugin_Call io_plugin_call = 590;
inline bool Container::has_io_plugin_call() const {
  return (_has_bits_[2] & 0x00200000u) != 0;
}
inline void Container::set_has_io_plugin_call() {
  _has_bits_[2] |= 0x00200000u;
}
inline void Container::clear_has_io_plugin_call() {
  _has_bits_[2] &= ~0x00200000u;
}
inline void Container::clear_io_plugin_call() {
  if (io_plugin_call_ != NULL) io_plugin_call_->::pb::Emc_Io_Plugin_Call::Clear();
  clear_has_io_plugin_call();
}
inline const ::pb::Emc_Io_Plugin_Call& Container::io_plugin_call() const {
  return io_plugin_call_ != NULL ? *io_plugin_call_ : *default_instance_->io_plugin_call_;
}
inline ::pb::Emc_Io_Plugin_Call* Container::mutable_io_plugin_call() {
  set_has_io_plugin_call();
  if (io_plugin_call_ == NULL) io_plugin_call_ = new ::pb::Emc_Io_Plugin_Call;
  return io_plugin_call_;
}
inline ::pb::Emc_Io_Plugin_Call* Container::release_io_plugin_call() {
  clear_has_io_plugin_call();
  ::pb::Emc_Io_Plugin_Call* temp = io_plugin_call_;
  io_plugin_call_ = NULL;
  return temp;
}

// optional .pb.EmcStatusConfig emc_status_config = 600;
inline bool Container::has_emc_status_config() const {
  return (_has_bits_[2] & 0x00400000u) != 0;
}
inline void Container::set_has_emc_status_config() {
  _has_bits_[2] |= 0x00400000u;
}
inline void Container::clear_has_emc_status_config() {
  _has_bits_[2] &= ~0x00400000u;
}
inline void Container::clear_emc_status_config() {
  if (emc_status_config_ != NULL) emc_status_config_->::pb::EmcStatusConfig::Clear();
  clear_has_emc_status_config();
}
inline const ::pb::EmcStatusConfig& Container::emc_status_config() const {
  return emc_status_config_ != NULL ? *emc_status_config_ : *default_instance_->emc_status_config_;
}
inline ::pb::EmcStatusConfig* Container::mutable_emc_status_config() {
  set_has_emc_status_config();
  if (emc_status_config_ == NULL) emc_status_config_ = new ::pb::EmcStatusConfig;
  return emc_status_config_;
}
inline ::pb::EmcStatusConfig* Container::release_emc_status_config() {
  clear_has_emc_status_config();
  ::pb::EmcStatusConfig* temp = emc_status_config_;
  emc_status_config_ = NULL;
  return temp;
}

// optional .pb.EmcStatusMotion emc_status_motion = 601;
inline bool Container::has_emc_status_motion() const {
  return (_has_bits_[2] & 0x00800000u) != 0;
}
inline void Container::set_has_emc_status_motion() {
  _has_bits_[2] |= 0x00800000u;
}
inline void Container::clear_has_emc_status_motion() {
  _has_bits_[2] &= ~0x00800000u;
}
inline void Container::clear_emc_status_motion() {
  if (emc_status_motion_ != NULL) emc_status_motion_->::pb::EmcStatusMotion::Clear();
  clear_has_emc_status_motion();
}
inline const ::pb::EmcStatusMotion& Container::emc_status_motion() const {
  return emc_status_motion_ != NULL ? *emc_status_motion_ : *default_instance_->emc_status_motion_;
}
inline ::pb::EmcStatusMotion* Container::mutable_emc_status_motion() {
  set_has_emc_status_motion();
  if (emc_status_motion_ == NULL) emc_status_motion_ = new ::pb::EmcStatusMotion;
  return emc_status_motion_;
}
inline ::pb::EmcStatusMotion* Container::release_emc_status_motion() {
  clear_has_emc_status_motion();
  ::pb::EmcStatusMotion* temp = emc_status_motion_;
  emc_status_motion_ = NULL;
  return temp;
}

// optional .pb.EmcStatusIo emc_status_io = 602;
inline bool Container::has_emc_status_io() const {
  return (_has_bits_[2] & 0x01000000u) != 0;
}
inline void Container::set_has_emc_status_io() {
  _has_bits_[2] |= 0x01000000u;
}
inline void Container::clear_has_emc_status_io() {
  _has_bits_[2] &= ~0x01000000u;
}
inline void Container::clear_emc_status_io() {
  if (emc_status_io_ != NULL) emc_status_io_->::pb::EmcStatusIo::Clear();
  clear_has_emc_status_io();
}
inline const ::pb::EmcStatusIo& Container::emc_status_io() const {
  return emc_status_io_ != NULL ? *emc_status_io_ : *default_instance_->emc_status_io_;
}
inline ::pb::EmcStatusIo* Container::mutable_emc_status_io() {
  set_has_emc_status_io();
  if (emc_status_io_ == NULL) emc_status_io_ = new ::pb::EmcStatusIo;
  return emc_status_io_;
}
inline ::pb::EmcStatusIo* Container::release_emc_status_io() {
  clear_has_emc_status_io();
  ::pb::EmcStatusIo* temp = emc_status_io_;
  emc_status_io_ = NULL;
  return temp;
}

// optional .pb.EmcStatusTask emc_status_task = 603;
inline bool Container::has_emc_status_task() const {
  return (_has_bits_[2] & 0x02000000u) != 0;
}
inline void Container::set_has_emc_status_task() {
  _has_bits_[2] |= 0x02000000u;
}
inline void Container::clear_has_emc_status_task() {
  _has_bits_[2] &= ~0x02000000u;
}
inline void Container::clear_emc_status_task() {
  if (emc_status_task_ != NULL) emc_status_task_->::pb::EmcStatusTask::Clear();
  clear_has_emc_status_task();
}
inline const ::pb::EmcStatusTask& Container::emc_status_task() const {
  return emc_status_task_ != NULL ? *emc_status_task_ : *default_instance_->emc_status_task_;
}
inline ::pb::EmcStatusTask* Container::mutable_emc_status_task() {
  set_has_emc_status_task();
  if (emc_status_task_ == NULL) emc_status_task_ = new ::pb::EmcStatusTask;
  return emc_status_task_;
}
inline ::pb::EmcStatusTask* Container::release_emc_status_task() {
  clear_has_emc_status_task();
  ::pb::EmcStatusTask* temp = emc_status_task_;
  emc_status_task_ = NULL;
  return temp;
}

// optional .pb.EmcStatusInterp emc_status_interp = 604;
inline bool Container::has_emc_status_interp() const {
  return (_has_bits_[2] & 0x04000000u) != 0;
}
inline void Container::set_has_emc_status_interp() {
  _has_bits_[2] |= 0x04000000u;
}
inline void Container::clear_has_emc_status_interp() {
  _has_bits_[2] &= ~0x04000000u;
}
inline void Container::clear_emc_status_interp() {
  if (emc_status_interp_ != NULL) emc_status_interp_->::pb::EmcStatusInterp::Clear();
  clear_has_emc_status_interp();
}
inline const ::pb::EmcStatusInterp& Container::emc_status_interp() const {
  return emc_status_interp_ != NULL ? *emc_status_interp_ : *default_instance_->emc_status_interp_;
}
inline ::pb::EmcStatusInterp* Container::mutable_emc_status_interp() {
  set_has_emc_status_interp();
  if (emc_status_interp_ == NULL) emc_status_interp_ = new ::pb::EmcStatusInterp;
  return emc_status_interp_;
}
inline ::pb::EmcStatusInterp* Container::release_emc_status_interp() {
  clear_has_emc_status_interp();
  ::pb::EmcStatusInterp* temp = emc_status_interp_;
  emc_status_interp_ = NULL;
  return temp;
}

// optional .pb.EmcCommandParameters emc_command_params = 610;
inline bool Container::has_emc_command_params() const {
  return (_has_bits_[2] & 0x08000000u) != 0;
}
inline void Container::set_has_emc_command_params() {
  _has_bits_[2] |= 0x08000000u;
}
inline void Container::clear_has_emc_command_params() {
  _has_bits_[2] &= ~0x08000000u;
}
inline void Container::clear_emc_command_params() {
  if (emc_command_params_ != NULL) emc_command_params_->::pb::EmcCommandParameters::Clear();
  clear_has_emc_command_params();
}
inline const ::pb::EmcCommandParameters& Container::emc_command_params() const {
  return emc_command_params_ != NULL ? *emc_command_params_ : *default_instance_->emc_command_params_;
}
inline ::pb::EmcCommandParameters* Container::mutable_emc_command_params() {
  set_has_emc_command_params();
  if (emc_command_params_ == NULL) emc_command_params_ = new ::pb::EmcCommandParameters;
  return emc_command_params_;
}
inline ::pb::EmcCommandParameters* Container::release_emc_command_params() {
  clear_has_emc_command_params();
  ::pb::EmcCommandParameters* temp = emc_command_params_;
  emc_command_params_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
